{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n/**\n *  A **FallbackProvider** provides resilience, security and performance\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport { assert, assertArgument, getBigInt, getNumber, isError } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction stringify(value) {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === \"bigint\") {\n      return {\n        type: \"bigint\",\n        value: value.toString()\n      };\n    }\n    return value;\n  });\n}\n;\nconst defaultConfig = {\n  stallTimeout: 400,\n  priority: 1,\n  weight: 1\n};\nconst defaultState = {\n  blockNumber: -2,\n  requests: 0,\n  lateResponses: 0,\n  errorResponses: 0,\n  outOfSync: -1,\n  unsupportedEvents: 0,\n  rollingDuration: 0,\n  score: 0,\n  _network: null,\n  _updateNumber: null,\n  _totalTime: 0,\n  _lastFatalError: null,\n  _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n    if (!config._updateNumber) {\n      config._updateNumber = (async () => {\n        try {\n          const blockNumber = await config.provider.getBlockNumber();\n          if (blockNumber > config.blockNumber) {\n            config.blockNumber = blockNumber;\n          }\n        } catch (error) {\n          config.blockNumber = -2;\n          config._lastFatalError = error;\n          config._lastFatalErrorTimestamp = getTime();\n        }\n        config._updateNumber = null;\n      })();\n    }\n    await config._updateNumber;\n    config.outOfSync++;\n    if (config._lastFatalError) {\n      break;\n    }\n  }\n}\nfunction _normalize(value) {\n  if (value == null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(_normalize).join(\",\") + \"]\";\n  }\n  if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n    return _normalize(value.toJSON());\n  }\n  switch (typeof value) {\n    case \"boolean\":\n    case \"symbol\":\n      return value.toString();\n    case \"bigint\":\n    case \"number\":\n      return BigInt(value).toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"object\":\n      {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(k => \"\".concat(JSON.stringify(k), \":\").concat(_normalize(value[k]))).join(\",\") + \"}\";\n      }\n  }\n  console.log(\"Could not serialize\", value);\n  throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(method, value) {\n  if (\"error\" in value) {\n    const error = value.error;\n    let tag;\n    if (isError(error, \"CALL_EXCEPTION\")) {\n      tag = _normalize(Object.assign({}, error, {\n        shortMessage: undefined,\n        reason: undefined,\n        info: undefined\n      }));\n    } else {\n      tag = _normalize(error);\n    }\n    return {\n      tag,\n      value: error\n    };\n  }\n  const result = value.result;\n  return {\n    tag: _normalize(result),\n    value: result\n  };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n  const tally = new Map();\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    const t = tally.get(tag) || {\n      value,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(tag, t);\n  }\n  let best = null;\n  for (const r of tally.values()) {\n    if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n      best = r;\n    }\n  }\n  if (best) {\n    return best.value;\n  }\n  return undefined;\n}\nfunction getMedian(quorum, results) {\n  let resultWeight = 0;\n  const errorMap = new Map();\n  let bestError = null;\n  const values = [];\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    if (value instanceof Error) {\n      const e = errorMap.get(tag) || {\n        value,\n        weight: 0\n      };\n      e.weight += weight;\n      errorMap.set(tag, e);\n      if (bestError == null || e.weight > bestError.weight) {\n        bestError = e;\n      }\n    } else {\n      values.push(BigInt(value));\n      resultWeight += weight;\n    }\n  }\n  if (resultWeight < quorum) {\n    // We have quorum for an error\n    if (bestError && bestError.weight >= quorum) {\n      return bestError.value;\n    }\n    // We do not have quorum for a result\n    return undefined;\n  }\n  // Get the sorted values\n  values.sort((a, b) => a < b ? -1 : b > a ? 1 : 0);\n  const mid = Math.floor(values.length / 2);\n  // Odd-length; take the middle value\n  if (values.length % 2) {\n    return values[mid];\n  }\n  // Even length; take the ceiling of the mean of the center two values\n  return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n  // If any value or error meets quorum, that is our preferred result\n  const result = checkQuorum(quorum, results);\n  if (result !== undefined) {\n    return result;\n  }\n  // Otherwise, do we have any result?\n  for (const r of results) {\n    if (r.value) {\n      return r.value;\n    }\n  }\n  // Nope!\n  return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n  if (quorum === 1) {\n    return getNumber(getMedian(quorum, results), \"%internal\");\n  }\n  const tally = new Map();\n  const add = (result, weight) => {\n    const t = tally.get(result) || {\n      result,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(result, t);\n  };\n  for (const {\n    weight,\n    value\n  } of results) {\n    const r = getNumber(value);\n    add(r - 1, weight);\n    add(r, weight);\n    add(r + 1, weight);\n  }\n  let bestWeight = 0;\n  let bestResult = undefined;\n  for (const {\n    weight,\n    result\n  } of tally.values()) {\n    // Use this result, if this result meets quorum and has either:\n    // - a better weight\n    // - or equal weight, but the result is larger\n    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {\n      bestWeight = weight;\n      bestResult = result;\n    }\n  }\n  return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resilience by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */\nvar _configs = /*#__PURE__*/new WeakMap();\nvar _height = /*#__PURE__*/new WeakMap();\nvar _initialSyncPromise = /*#__PURE__*/new WeakMap();\nvar _FallbackProvider_brand = /*#__PURE__*/new WeakSet();\nexport class FallbackProvider extends AbstractProvider {\n  /**\n   *  Creates a new **FallbackProvider** with %%providers%% connected to\n   *  %%network%%.\n   *\n   *  If a [[Provider]] is included in %%providers%%, defaults are used\n   *  for the configuration.\n   */\n  constructor(providers, _network, options) {\n    super(_network, options);\n    // Grab the next (random) config that is not already part of\n    // the running set\n    _classPrivateMethodInitSpec(this, _FallbackProvider_brand);\n    /**\n     *  The number of backends that must agree on a value before it is\n     *  accpeted.\n     */\n    _defineProperty(this, \"quorum\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"eventQuorum\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"eventWorkers\", void 0);\n    _classPrivateFieldInitSpec(this, _configs, void 0);\n    _classPrivateFieldInitSpec(this, _height, void 0);\n    _classPrivateFieldInitSpec(this, _initialSyncPromise, void 0);\n    _classPrivateFieldSet(_configs, this, providers.map(p => {\n      if (p instanceof AbstractProvider) {\n        return Object.assign({\n          provider: p\n        }, defaultConfig, defaultState);\n      } else {\n        return Object.assign({}, defaultConfig, p, defaultState);\n      }\n    }));\n    _classPrivateFieldSet(_height, this, -2);\n    _classPrivateFieldSet(_initialSyncPromise, this, null);\n    if (options && options.quorum != null) {\n      this.quorum = options.quorum;\n    } else {\n      this.quorum = Math.ceil(_classPrivateFieldGet(_configs, this).reduce((accum, config) => {\n        accum += config.weight;\n        return accum;\n      }, 0) / 2);\n    }\n    this.eventQuorum = 1;\n    this.eventWorkers = 1;\n    assertArgument(this.quorum <= _classPrivateFieldGet(_configs, this).reduce((a, c) => a + c.weight, 0), \"quorum exceed provider weight\", \"quorum\", this.quorum);\n  }\n  get providerConfigs() {\n    return _classPrivateFieldGet(_configs, this).map(c => {\n      const result = Object.assign({}, c);\n      for (const key in result) {\n        if (key[0] === \"_\") {\n          delete result[key];\n        }\n      }\n      return result;\n    });\n  }\n  async _detectNetwork() {\n    return Network.from(getBigInt(await this._perform({\n      method: \"chainId\"\n    })));\n  }\n  // @TODO: Add support to select providers to be the event subscriber\n  //_getSubscriber(sub: Subscription): Subscriber {\n  //    throw new Error(\"@TODO\");\n  //}\n  /**\n   *  Transforms a %%req%% into the correct method call on %%provider%%.\n   */\n  async _translatePerform(provider, req) {\n    switch (req.method) {\n      case \"broadcastTransaction\":\n        return await provider.broadcastTransaction(req.signedTransaction);\n      case \"call\":\n        return await provider.call(Object.assign({}, req.transaction, {\n          blockTag: req.blockTag\n        }));\n      case \"chainId\":\n        return (await provider.getNetwork()).chainId;\n      case \"estimateGas\":\n        return await provider.estimateGas(req.transaction);\n      case \"getBalance\":\n        return await provider.getBalance(req.address, req.blockTag);\n      case \"getBlock\":\n        {\n          const block = \"blockHash\" in req ? req.blockHash : req.blockTag;\n          return await provider.getBlock(block, req.includeTransactions);\n        }\n      case \"getBlockNumber\":\n        return await provider.getBlockNumber();\n      case \"getCode\":\n        return await provider.getCode(req.address, req.blockTag);\n      case \"getGasPrice\":\n        return (await provider.getFeeData()).gasPrice;\n      case \"getPriorityFee\":\n        return (await provider.getFeeData()).maxPriorityFeePerGas;\n      case \"getLogs\":\n        return await provider.getLogs(req.filter);\n      case \"getStorage\":\n        return await provider.getStorage(req.address, req.position, req.blockTag);\n      case \"getTransaction\":\n        return await provider.getTransaction(req.hash);\n      case \"getTransactionCount\":\n        return await provider.getTransactionCount(req.address, req.blockTag);\n      case \"getTransactionReceipt\":\n        return await provider.getTransactionReceipt(req.hash);\n      case \"getTransactionResult\":\n        return await provider.getTransactionResult(req.hash);\n    }\n  }\n  async _perform(req) {\n    // Broadcasting a transaction is rare (ish) and already incurs\n    // a cost on the user, so spamming is safe-ish. Just send it to\n    // every backend.\n    if (req.method === \"broadcastTransaction\") {\n      // Once any broadcast provides a positive result, use it. No\n      // need to wait for anyone else\n      const results = _classPrivateFieldGet(_configs, this).map(c => null);\n      const broadcasts = _classPrivateFieldGet(_configs, this).map(async (_ref, index) => {\n        let {\n          provider,\n          weight\n        } = _ref;\n        try {\n          const result = await provider._perform(req);\n          results[index] = Object.assign(normalizeResult(req.method, {\n            result\n          }), {\n            weight\n          });\n        } catch (error) {\n          results[index] = Object.assign(normalizeResult(req.method, {\n            error\n          }), {\n            weight\n          });\n        }\n      });\n      // As each promise finishes...\n      while (true) {\n        // Check for a valid broadcast result\n        const done = results.filter(r => r != null);\n        for (const {\n          value\n        } of done) {\n          if (!(value instanceof Error)) {\n            return value;\n          }\n        }\n        // Check for a legit broadcast error (one which we cannot\n        // recover from; some nodes may return the following red\n        // herring events:\n        // - alredy seend (UNKNOWN_ERROR)\n        // - NONCE_EXPIRED\n        // - REPLACEMENT_UNDERPRICED\n        const result = checkQuorum(this.quorum, results.filter(r => r != null));\n        if (isError(result, \"INSUFFICIENT_FUNDS\")) {\n          throw result;\n        }\n        // Kick off the next provider (if any)\n        const waiting = broadcasts.filter((b, i) => results[i] == null);\n        if (waiting.length === 0) {\n          break;\n        }\n        await Promise.race(waiting);\n      }\n      // Use standard quorum results; any result was returned above,\n      // so this will find any error that met quorum if any\n      const result = getAnyResult(this.quorum, results);\n      assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n        request: \"%sub-requests\",\n        info: {\n          request: req,\n          results: results.map(stringify)\n        }\n      });\n      if (result instanceof Error) {\n        throw result;\n      }\n      return result;\n    }\n    await _assertClassBrand(_FallbackProvider_brand, this, _initialSync).call(this);\n    // Bootstrap enough runners to meet quorum\n    const running = new Set();\n    let inflightQuorum = 0;\n    while (true) {\n      const runner = _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);\n      if (runner == null) {\n        break;\n      }\n      inflightQuorum += runner.config.weight;\n      if (inflightQuorum >= this.quorum) {\n        break;\n      }\n    }\n    const result = await _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);\n    // Track requests sent to a provider that are still\n    // outstanding after quorum has been otherwise found\n    for (const runner of running) {\n      if (runner.perform && runner.result == null) {\n        runner.config.lateResponses++;\n      }\n    }\n    return result;\n  }\n  async destroy() {\n    for (const {\n      provider\n    } of _classPrivateFieldGet(_configs, this)) {\n      provider.destroy();\n    }\n    super.destroy();\n  }\n}\n//# sourceMappingURL=provider-fallback.js.map\nfunction _getNextConfig(running) {\n  // @TODO: Maybe do a check here to favour (heavily) providers that\n  //        do not require waitForSync and disfavour providers that\n  //        seem down-ish or are behaving slowly\n  const configs = Array.from(running).map(r => r.config);\n  // Shuffle the states, sorted by priority\n  const allConfigs = _classPrivateFieldGet(_configs, this).slice();\n  shuffle(allConfigs);\n  allConfigs.sort((a, b) => a.priority - b.priority);\n  for (const config of allConfigs) {\n    if (config._lastFatalError) {\n      continue;\n    }\n    if (configs.indexOf(config) === -1) {\n      return config;\n    }\n  }\n  return null;\n}\n// Adds a new runner (if available) to running.\nfunction _addRunner(running, req) {\n  const config = _assertClassBrand(_FallbackProvider_brand, this, _getNextConfig).call(this, running);\n  // No runners available\n  if (config == null) {\n    return null;\n  }\n  // Create a new runner\n  const runner = {\n    config,\n    result: null,\n    didBump: false,\n    perform: null,\n    staller: null\n  };\n  const now = getTime();\n  // Start performing this operation\n  runner.perform = (async () => {\n    try {\n      config.requests++;\n      const result = await this._translatePerform(config.provider, req);\n      runner.result = {\n        result\n      };\n    } catch (error) {\n      config.errorResponses++;\n      runner.result = {\n        error\n      };\n    }\n    const dt = getTime() - now;\n    config._totalTime += dt;\n    config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n    runner.perform = null;\n  })();\n  // Start a staller; when this times out, it's time to force\n  // kicking off another runner because we are taking too long\n  runner.staller = (async () => {\n    await stall(config.stallTimeout);\n    runner.staller = null;\n  })();\n  running.add(runner);\n  return runner;\n}\n// Initializes the blockNumber and network for each runner and\n// blocks until initialized\nasync function _initialSync() {\n  let initialSync = _classPrivateFieldGet(_initialSyncPromise, this);\n  if (!initialSync) {\n    const promises = [];\n    _classPrivateFieldGet(_configs, this).forEach(config => {\n      promises.push((async () => {\n        await waitForSync(config, 0);\n        if (!config._lastFatalError) {\n          config._network = await config.provider.getNetwork();\n        }\n      })());\n    });\n    _classPrivateFieldSet(_initialSyncPromise, this, initialSync = (async () => {\n      // Wait for all providers to have a block number and network\n      await Promise.all(promises);\n      // Check all the networks match\n      let chainId = null;\n      for (const config of _classPrivateFieldGet(_configs, this)) {\n        if (config._lastFatalError) {\n          continue;\n        }\n        const network = config._network;\n        if (chainId == null) {\n          chainId = network.chainId;\n        } else if (network.chainId !== chainId) {\n          assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"new FallbackProvider\"\n          });\n        }\n      }\n    })());\n  }\n  await initialSync;\n}\nasync function _checkQuorum(running, req) {\n  // Get all the result objects\n  const results = [];\n  for (const runner of running) {\n    if (runner.result != null) {\n      const {\n        tag,\n        value\n      } = normalizeResult(req.method, runner.result);\n      results.push({\n        tag,\n        value,\n        weight: runner.config.weight\n      });\n    }\n  }\n  // Are there enough results to event meet quorum?\n  if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {\n    return undefined;\n  }\n  switch (req.method) {\n    case \"getBlockNumber\":\n      {\n        // We need to get the bootstrap block height\n        if (_classPrivateFieldGet(_height, this) === -2) {\n          _classPrivateFieldSet(_height, this, Math.ceil(getNumber(getMedian(this.quorum, _classPrivateFieldGet(_configs, this).filter(c => !c._lastFatalError).map(c => ({\n            value: c.blockNumber,\n            tag: getNumber(c.blockNumber).toString(),\n            weight: c.weight\n          }))))));\n        }\n        // Find the mode across all the providers, allowing for\n        // a little drift between block heights\n        const mode = getFuzzyMode(this.quorum, results);\n        if (mode === undefined) {\n          return undefined;\n        }\n        if (mode > _classPrivateFieldGet(_height, this)) {\n          _classPrivateFieldSet(_height, this, mode);\n        }\n        return _classPrivateFieldGet(_height, this);\n      }\n    case \"getGasPrice\":\n    case \"getPriorityFee\":\n    case \"estimateGas\":\n      return getMedian(this.quorum, results);\n    case \"getBlock\":\n      // Pending blocks are in the mempool and already\n      // quite untrustworthy; just grab anything\n      if (\"blockTag\" in req && req.blockTag === \"pending\") {\n        return getAnyResult(this.quorum, results);\n      }\n      return checkQuorum(this.quorum, results);\n    case \"call\":\n    case \"chainId\":\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorage\":\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n    case \"getLogs\":\n      return checkQuorum(this.quorum, results);\n    case \"broadcastTransaction\":\n      return getAnyResult(this.quorum, results);\n  }\n  assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"_perform(\".concat(stringify(req.method), \")\")\n  });\n}\nasync function _waitForQuorum(running, req) {\n  if (running.size === 0) {\n    throw new Error(\"no runners?!\");\n  }\n  // Any promises that are interesting to watch for; an expired stall\n  // or a successful perform\n  const interesting = [];\n  let newRunners = 0;\n  for (const runner of running) {\n    // No responses, yet; keep an eye on it\n    if (runner.perform) {\n      interesting.push(runner.perform);\n    }\n    // Still stalling...\n    if (runner.staller) {\n      interesting.push(runner.staller);\n      continue;\n    }\n    // This runner has already triggered another runner\n    if (runner.didBump) {\n      continue;\n    }\n    // Got a response (result or error) or stalled; kick off another runner\n    runner.didBump = true;\n    newRunners++;\n  }\n  // Check if we have reached quorum on a result (or error)\n  const value = await _assertClassBrand(_FallbackProvider_brand, this, _checkQuorum).call(this, running, req);\n  if (value !== undefined) {\n    if (value instanceof Error) {\n      throw value;\n    }\n    return value;\n  }\n  // Add any new runners, because a staller timed out or a result\n  // or error response came in.\n  for (let i = 0; i < newRunners; i++) {\n    _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);\n  }\n  // All providers have returned, and we have no result\n  assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n    request: \"%sub-requests\",\n    info: {\n      request: req,\n      results: Array.from(running).map(r => stringify(r.result))\n    }\n  });\n  // Wait for someone to either complete its perform or stall out\n  await Promise.race(interesting);\n  // This is recursive, but at worst case the depth is 2x the\n  // number of providers (each has a perform and a staller)\n  return await _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}