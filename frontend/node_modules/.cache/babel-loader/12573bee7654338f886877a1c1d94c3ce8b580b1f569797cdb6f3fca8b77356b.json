{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _interval = /*#__PURE__*/new WeakMap();\nvar _blockNumber = /*#__PURE__*/new WeakMap();\nvar _PollingBlockSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class PollingBlockSubscriber {\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _PollingBlockSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider, void 0);\n    _classPrivateFieldInitSpec(this, _poller, void 0);\n    _classPrivateFieldInitSpec(this, _interval, void 0);\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    _classPrivateFieldInitSpec(this, _blockNumber, void 0);\n    _classPrivateFieldSet(_provider, this, provider);\n    _classPrivateFieldSet(_poller, this, null);\n    _classPrivateFieldSet(_interval, this, 4000);\n    _classPrivateFieldSet(_blockNumber, this, -2);\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(_interval, this);\n  }\n  set pollingInterval(value) {\n    _classPrivateFieldSet(_interval, this, value);\n  }\n  start() {\n    if (_classPrivateFieldGet(_poller, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));\n    _assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).call(this);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_poller, this)) {\n      return;\n    }\n    _classPrivateFieldGet(_provider, this)._clearTimeout(_classPrivateFieldGet(_poller, this));\n    _classPrivateFieldSet(_poller, this, null);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_blockNumber, this, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll() {\n  try {\n    const blockNumber = await _classPrivateFieldGet(_provider, this).getBlockNumber();\n    // Bootstrap poll to setup our initial block number\n    if (_classPrivateFieldGet(_blockNumber, this) === -2) {\n      _classPrivateFieldSet(_blockNumber, this, blockNumber);\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== _classPrivateFieldGet(_blockNumber, this)) {\n      for (let b = _classPrivateFieldGet(_blockNumber, this) + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (_classPrivateFieldGet(_poller, this) == null) {\n          return;\n        }\n        await _classPrivateFieldGet(_provider, this).emit(\"block\", b);\n      }\n      _classPrivateFieldSet(_blockNumber, this, blockNumber);\n    }\n  } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n  }\n  // We have been stopped\n  if (_classPrivateFieldGet(_poller, this) == null) {\n    return;\n  }\n  _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));\n}\nvar _provider2 = /*#__PURE__*/new WeakMap();\nvar _poll2 = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nexport class OnBlockSubscriber {\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateFieldInitSpec(this, _provider2, void 0);\n    _classPrivateFieldInitSpec(this, _poll2, void 0);\n    _classPrivateFieldInitSpec(this, _running, void 0);\n    _classPrivateFieldSet(_provider2, this, provider);\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_poll2, this, blockNumber => {\n      this._poll(blockNumber, _classPrivateFieldGet(_provider2, this));\n    });\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, true);\n    _classPrivateFieldGet(_poll2, this).call(this, -2);\n    _classPrivateFieldGet(_provider2, this).on(\"block\", _classPrivateFieldGet(_poll2, this));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldGet(_provider2, this).off(\"block\", _classPrivateFieldGet(_poll2, this));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nvar _tag = /*#__PURE__*/new WeakMap();\nvar _lastBlock = /*#__PURE__*/new WeakMap();\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  constructor(provider, tag) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _tag, void 0);\n    _classPrivateFieldInitSpec(this, _lastBlock, void 0);\n    _classPrivateFieldSet(_tag, this, tag);\n    _classPrivateFieldSet(_lastBlock, this, -2);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_lastBlock, this, -2);\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(_classPrivateFieldGet(_tag, this));\n    if (block == null) {\n      return;\n    }\n    if (_classPrivateFieldGet(_lastBlock, this) === -2) {\n      _classPrivateFieldSet(_lastBlock, this, block.number);\n    } else if (block.number > _classPrivateFieldGet(_lastBlock, this)) {\n      provider.emit(_classPrivateFieldGet(_tag, this), block.number);\n      _classPrivateFieldSet(_lastBlock, this, block.number);\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _filter = /*#__PURE__*/new WeakMap();\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _filter, void 0);\n    _classPrivateFieldSet(_filter, this, copy(filter));\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(_classPrivateFieldGet(_filter, this));\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _hash = /*#__PURE__*/new WeakMap();\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _hash, void 0);\n    _classPrivateFieldSet(_hash, this, hash);\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(_classPrivateFieldGet(_hash, this));\n    if (tx) {\n      provider.emit(_classPrivateFieldGet(_hash, this), tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider3 = /*#__PURE__*/new WeakMap();\nvar _filter2 = /*#__PURE__*/new WeakMap();\nvar _poller2 = /*#__PURE__*/new WeakMap();\nvar _running2 = /*#__PURE__*/new WeakMap();\nvar _blockNumber2 = /*#__PURE__*/new WeakMap();\nvar _PollingEventSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class PollingEventSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, _filter3) {\n    _classPrivateMethodInitSpec(this, _PollingEventSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider3, void 0);\n    _classPrivateFieldInitSpec(this, _filter2, void 0);\n    _classPrivateFieldInitSpec(this, _poller2, void 0);\n    _classPrivateFieldInitSpec(this, _running2, void 0);\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    _classPrivateFieldInitSpec(this, _blockNumber2, void 0);\n    _classPrivateFieldSet(_provider3, this, provider);\n    _classPrivateFieldSet(_filter2, this, copy(_filter3));\n    _classPrivateFieldSet(_poller2, this, _assertClassBrand(_PollingEventSubscriber_brand, this, _poll3).bind(this));\n    _classPrivateFieldSet(_running2, this, false);\n    _classPrivateFieldSet(_blockNumber2, this, -2);\n  }\n  start() {\n    if (_classPrivateFieldGet(_running2, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running2, this, true);\n    if (_classPrivateFieldGet(_blockNumber2, this) === -2) {\n      _classPrivateFieldGet(_provider3, this).getBlockNumber().then(blockNumber => {\n        _classPrivateFieldSet(_blockNumber2, this, blockNumber);\n      });\n    }\n    _classPrivateFieldGet(_provider3, this).on(\"block\", _classPrivateFieldGet(_poller2, this));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running2, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running2, this, false);\n    _classPrivateFieldGet(_provider3, this).off(\"block\", _classPrivateFieldGet(_poller2, this));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(_blockNumber2, this, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n//# sourceMappingURL=subscriber-polling.js.map\nasync function _poll3(blockNumber) {\n  // The initial block hasn't been determined yet\n  if (_classPrivateFieldGet(_blockNumber2, this) === -2) {\n    return;\n  }\n  const filter = copy(_classPrivateFieldGet(_filter2, this));\n  filter.fromBlock = _classPrivateFieldGet(_blockNumber2, this) + 1;\n  filter.toBlock = blockNumber;\n  const logs = await _classPrivateFieldGet(_provider3, this).getLogs(filter);\n  // No logs could just mean the node has not indexed them yet,\n  // so we keep a sliding window of 60 blocks to keep scanning\n  if (logs.length === 0) {\n    if (_classPrivateFieldGet(_blockNumber2, this) < blockNumber - 60) {\n      _classPrivateFieldSet(_blockNumber2, this, blockNumber - 60);\n    }\n    return;\n  }\n  for (const log of logs) {\n    _classPrivateFieldGet(_provider3, this).emit(_classPrivateFieldGet(_filter2, this), log);\n    // Only advance the block number when logs were found to\n    // account for networks (like BNB and Polygon) which may\n    // sacrifice event consistency for block event speed\n    _classPrivateFieldSet(_blockNumber2, this, log.blockNumber);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}