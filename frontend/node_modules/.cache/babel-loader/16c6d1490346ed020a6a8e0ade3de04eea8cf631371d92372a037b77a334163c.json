{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nimport { keccak256 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, getBytesCopy, hexlify, zeroPadBytes, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex, assert } from \"../utils/index.js\";\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType } from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\nexport { checkResultErrors, Result };\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, topic, args) {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Event.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The full Event signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The topic hash for the Event.\n     */\n    _defineProperty(this, \"topic\", void 0);\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      signature,\n      topic,\n      args\n    });\n  }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args, value) {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    _defineProperty(this, \"value\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector,\n      value\n    });\n  }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n  /**\n   *  @_ignore:\n   */\n  constructor(fragment, selector, args) {\n    /**\n     *  The matching fragment.\n     */\n    _defineProperty(this, \"fragment\", void 0);\n    /**\n     *  The name of the Error.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    _defineProperty(this, \"args\", void 0);\n    /**\n     *  The full Error signature.\n     */\n    _defineProperty(this, \"signature\", void 0);\n    /**\n     *  The selector for the Error.\n     */\n    _defineProperty(this, \"selector\", void 0);\n    const name = fragment.name,\n      signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector\n    });\n  }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n  /**\n   *  Returns ``true`` if %%value%% is an **Indexed**.\n   *\n   *  This provides a Type Guard for property access.\n   */\n  static isIndexed(value) {\n    return !!(value && value._isIndexed);\n  }\n  /**\n   *  @_ignore:\n   */\n  constructor(hash) {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    _defineProperty(this, \"hash\", void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"_isIndexed\", void 0);\n    defineProperties(this, {\n      hash,\n      _isIndexed: true\n    });\n  }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: message => {\n      return \"reverted with reason string \".concat(JSON.stringify(message));\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: code => {\n      let reason = \"unknown panic code\";\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n      return \"reverted with panic code 0x\".concat(code.toString(16), \" (\").concat(reason, \")\");\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nvar _errors = /*#__PURE__*/new WeakMap();\nvar _events = /*#__PURE__*/new WeakMap();\nvar _functions = /*#__PURE__*/new WeakMap();\nvar _abiCoder = /*#__PURE__*/new WeakMap();\nvar _Interface_brand = /*#__PURE__*/new WeakSet();\nexport class Interface {\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n  constructor(fragments) {\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _Interface_brand);\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    _defineProperty(this, \"fragments\", void 0);\n    /**\n     *  The Contract constructor.\n     */\n    _defineProperty(this, \"deploy\", void 0);\n    /**\n     *  The Fallback method, if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    /**\n     *  If receiving ether is supported.\n     */\n    _defineProperty(this, \"receive\", void 0);\n    _classPrivateFieldInitSpec(this, _errors, void 0);\n    _classPrivateFieldInitSpec(this, _events, void 0);\n    _classPrivateFieldInitSpec(this, _functions, void 0);\n    //    #structs: Map<string, StructFragment>;\n    _classPrivateFieldInitSpec(this, _abiCoder, void 0);\n    let abi = [];\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n    _classPrivateFieldSet(_functions, this, new Map());\n    _classPrivateFieldSet(_errors, this, new Map());\n    _classPrivateFieldSet(_events, this, new Map());\n    //        this.#structs = new Map();\n    const frags = [];\n    for (const a of abi) {\n      try {\n        frags.push(Fragment.from(a));\n      } catch (error) {\n        console.log(\"[Warning] Invalid Fragment \".concat(JSON.stringify(a), \":\"), error.message);\n      }\n    }\n    defineProperties(this, {\n      fragments: Object.freeze(frags)\n    });\n    let fallback = null;\n    let receive = false;\n    _classPrivateFieldSet(_abiCoder, this, this.getAbiCoder());\n    // Add all fragments by their signature\n    this.fragments.forEach((fragment, index) => {\n      let bucket;\n      switch (fragment.type) {\n        case \"constructor\":\n          if (this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          }\n          //checkNames(fragment, \"input\", fragment.inputs);\n          defineProperties(this, {\n            deploy: fragment\n          });\n          return;\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            assertArgument(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", \"fragments[\".concat(index, \"]\"), fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n          return;\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = _classPrivateFieldGet(_functions, this);\n          break;\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = _classPrivateFieldGet(_events, this);\n          break;\n        case \"error\":\n          bucket = _classPrivateFieldGet(_errors, this);\n          break;\n        default:\n          return;\n      }\n      // Two identical entries; ignore it\n      const signature = fragment.format();\n      if (bucket.has(signature)) {\n        return;\n      }\n      bucket.set(signature, fragment);\n    });\n    // If we do not have a constructor add a default\n    if (!this.deploy) {\n      defineProperties(this, {\n        deploy: ConstructorFragment.from(\"constructor()\")\n      });\n    }\n    defineProperties(this, {\n      fallback,\n      receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n  format(minimal) {\n    const format = minimal ? \"minimal\" : \"full\";\n    const abi = this.fragments.map(f => f.format(format));\n    return abi;\n  }\n  /**\n   *  Return the JSON-encoded ABI. This is the format Solidiy\n   *  returns.\n   */\n  formatJson() {\n    const abi = this.fragments.map(f => f.format(\"json\"));\n    // We need to re-bundle the JSON fragments a bit\n    return JSON.stringify(abi.map(j => JSON.parse(j)));\n  }\n  /**\n   *  The ABI coder that will be used to encode and decode binary\n   *  data.\n   */\n  getAbiCoder() {\n    return AbiCoder.defaultAbiCoder();\n  }\n  /**\n   *  Get the function name for %%key%%, which may be a function selector,\n   *  function name or function signature that belongs to the ABI.\n   */\n  getFunctionName(key) {\n    const fragment = _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);\n    assertArgument(fragment, \"no matching function\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (a function selector, function name or\n   *  function signature) is present in the ABI.\n   *\n   *  In the case of a function name, the name may be ambiguous, so\n   *  accessing the [[FunctionFragment]] may require refinement.\n   */\n  hasFunction(key) {\n    return !!_assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n   *  selector, function name or function signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple functions match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single function in\n   *  the ABI, this will throw.\n   */\n  getFunction(key, values) {\n    return _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all functions, calling %%callback%%, sorted by their name.\n   */\n  forEachFunction(callback) {\n    const names = Array.from(_classPrivateFieldGet(_functions, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_functions, this).get(name), i);\n    }\n  }\n  // Find an event definition by any means necessary (unless it is ambiguous)\n\n  /**\n   *  Get the event name for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   */\n  getEventName(key) {\n    const fragment = _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);\n    assertArgument(fragment, \"no matching event\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Returns true if %%key%% (an event topic hash, event name or\n   *  event signature) is present in the ABI.\n   *\n   *  In the case of an event name, the name may be ambiguous, so\n   *  accessing the [[EventFragment]] may require refinement.\n   */\n  hasEvent(key) {\n    return !!_assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);\n  }\n  /**\n   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple events match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single event in\n   *  the ABI, this will throw.\n   */\n  getEvent(key, values) {\n    return _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, values || null, true);\n  }\n  /**\n   *  Iterate over all events, calling %%callback%%, sorted by their name.\n   */\n  forEachEvent(callback) {\n    const names = Array.from(_classPrivateFieldGet(_events, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_events, this).get(name), i);\n    }\n  }\n  /**\n   *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n   *  selector, error name or error signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple errors match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single error in\n   *  the ABI, this will throw.\n   */\n  getError(key, values) {\n    if (isHexString(key)) {\n      const selector = key.toLowerCase();\n      if (BuiltinErrors[selector]) {\n        return ErrorFragment.from(BuiltinErrors[selector].signature);\n      }\n      for (const fragment of _classPrivateFieldGet(_errors, this).values()) {\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n      return null;\n    }\n    // It is a bare name, look up the function (will return null if ambiguous)\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n      for (const [name, fragment] of _classPrivateFieldGet(_errors, this)) {\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(fragment);\n        }\n      }\n      if (matching.length === 0) {\n        if (key === \"Error\") {\n          return ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic\") {\n          return ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        return null;\n      } else if (matching.length > 1) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        assertArgument(false, \"ambiguous error description (i.e. \".concat(matchStr, \")\"), \"name\", key);\n      }\n      return matching[0];\n    }\n    // Normalize the signature and lookup the function\n    key = ErrorFragment.from(key).format();\n    if (key === \"Error(string)\") {\n      return ErrorFragment.from(\"error Error(string)\");\n    }\n    if (key === \"Panic(uint256)\") {\n      return ErrorFragment.from(\"error Panic(uint256)\");\n    }\n    const result = _classPrivateFieldGet(_errors, this).get(key);\n    if (result) {\n      return result;\n    }\n    return null;\n  }\n  /**\n   *  Iterate over all errors, calling %%callback%%, sorted by their name.\n   */\n  forEachError(callback) {\n    const names = Array.from(_classPrivateFieldGet(_errors, this).keys());\n    names.sort((a, b) => a.localeCompare(b));\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(_classPrivateFieldGet(_errors, this).get(name), i);\n    }\n  }\n  // Get the 4-byte selector used by Solidity to identify a function\n  /*\n  getSelector(fragment: ErrorFragment | FunctionFragment): string {\n  if (typeof(fragment) === \"string\") {\n      const matches: Array<Fragment> = [ ];\n       try { matches.push(this.getFunction(fragment)); } catch (error) { }\n      try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n       if (matches.length === 0) {\n          logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n      } else if (matches.length > 1) {\n          logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n      }\n       fragment = matches[0];\n  }\n   return dataSlice(id(fragment.format()), 0, 4);\n  }\n  */\n  // Get the 32-byte topic hash used by Solidity to identify an event\n  /*\n  getEventTopic(fragment: EventFragment): string {\n      //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n      return id(fragment.format());\n  }\n  */\n  _decodeParams(params, data) {\n    return _classPrivateFieldGet(_abiCoder, this).decode(params, data);\n  }\n  _encodeParams(params, values) {\n    return _classPrivateFieldGet(_abiCoder, this).encode(params, values);\n  }\n  /**\n   *  Encodes a ``tx.data`` object for deploying the Contract with\n   *  the %%values%% as the constructor arguments.\n   */\n  encodeDeploy(values) {\n    return this._encodeParams(this.deploy.inputs, values || []);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified error (see [[getError]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeErrorResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match error \".concat(fragment.name, \".\"), \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the transaction revert data for a call result that\n   *  reverted from the the Contract with the sepcified %%error%%\n   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeErrorResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the %%data%% from a transaction ``tx.data`` for\n   *  the function specified (see [[getFunction]] for valid values\n   *  for %%fragment%%).\n   *\n   *  Most developers should prefer the [[parseTransaction]] method\n   *  instead, which will automatically detect the fragment.\n   */\n  decodeFunctionData(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match function \".concat(fragment.name, \".\"), \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the ``tx.data`` for a transaction that calls the function\n   *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n   *  the %%values%%.\n   */\n  encodeFunctionData(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseCallResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n  decodeFunctionResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    let message = \"invalid length for result data\";\n    const bytes = getBytesCopy(data);\n    if (bytes.length % 32 === 0) {\n      try {\n        return _classPrivateFieldGet(_abiCoder, this).decode(fragment.outputs, bytes);\n      } catch (error) {\n        message = \"could not decode result data\";\n      }\n    }\n    // Call returned data with no error, but the data is junk\n    assert(false, message, \"BAD_DATA\", {\n      value: hexlify(bytes),\n      info: {\n        method: fragment.name,\n        signature: fragment.format()\n      }\n    });\n  }\n  makeError(_data, tx) {\n    const data = getBytes(_data, \"data\");\n    const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n    // Not a built-in error; try finding a custom error\n    const customPrefix = \"execution reverted (unknown custom error)\";\n    if (error.message.startsWith(customPrefix)) {\n      const selector = hexlify(data.slice(0, 4));\n      const ef = this.getError(selector);\n      if (ef) {\n        try {\n          const args = _classPrivateFieldGet(_abiCoder, this).decode(ef.inputs, data.slice(4));\n          error.revert = {\n            name: ef.name,\n            signature: ef.format(),\n            args\n          };\n          error.reason = error.revert.signature;\n          error.message = \"execution reverted: \".concat(error.reason);\n        } catch (e) {\n          error.message = \"execution reverted (coult not decode custom error)\";\n        }\n      }\n    }\n    // Add the invocation, if available\n    const parsed = this.parseTransaction(tx);\n    if (parsed) {\n      error.invocation = {\n        method: parsed.name,\n        signature: parsed.signature,\n        args: parsed.args\n      };\n    }\n    return error;\n  }\n  /**\n   *  Encodes the result data (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values\n   *  for %%fragment%%) with %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n  encodeFunctionResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n    return hexlify(_classPrivateFieldGet(_abiCoder, this).encode(fragment.outputs, values || []));\n  }\n  /*\n      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n          const promises: Array<Promise<>> = [ ];\n          const process = function(type: ParamType, value: any): any {\n              if (type.baseType === \"array\") {\n                  return descend(type.child\n              }\n              if (type. === \"address\") {\n              }\n          };\n  \n          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n              if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n              \n          };\n  \n          const result: Array<any> = [ ];\n          values.forEach((value, index) => {\n              if (value == null) {\n                  topics.push(null);\n              } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                  logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n              } else if (Array.isArray(value)) {\n                  topics.push(value.map((value) => encodeTopic(param, value)));\n              } else {\n                  topics.push(encodeTopic(param, value));\n              }\n          });\n      }\n  */\n  // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n  encodeFilterTopics(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    assert(values.length <= fragment.inputs.length, \"too many arguments for \".concat(fragment.format()), \"UNEXPECTED_ARGUMENT\", {\n      count: values.length,\n      expectedCount: fragment.inputs.length\n    });\n    const topics = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    // @TODO: Use the coders for this; to properly support tuples, etc.\n    const encodeTopic = (param, value) => {\n      if (param.type === \"string\") {\n        return id(value);\n      } else if (param.type === \"bytes\") {\n        return keccak256(hexlify(value));\n      }\n      if (param.type === \"bool\" && typeof value === \"boolean\") {\n        value = value ? \"0x01\" : \"0x00\";\n      } else if (param.type.match(/^u?int/)) {\n        value = toBeHex(value); // @TODO: Should this toTwos??\n      } else if (param.type.match(/^bytes/)) {\n        value = zeroPadBytes(value, 32);\n      } else if (param.type === \"address\") {\n        // Check addresses are valid\n        _classPrivateFieldGet(_abiCoder, this).encode([\"address\"], [value]);\n      }\n      return zeroPadValue(hexlify(value), 32);\n    };\n    values.forEach((value, index) => {\n      const param = fragment.inputs[index];\n      if (!param.indexed) {\n        assertArgument(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n        return;\n      }\n      if (value == null) {\n        topics.push(null);\n      } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n        assertArgument(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n      } else if (Array.isArray(value)) {\n        topics.push(value.map(value => encodeTopic(param, value)));\n      } else {\n        topics.push(encodeTopic(param, value));\n      }\n    });\n    // Trim off trailing nulls\n    while (topics.length && topics[topics.length - 1] === null) {\n      topics.pop();\n    }\n    return topics;\n  }\n  encodeEventLog(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    const topics = [];\n    const dataTypes = [];\n    const dataValues = [];\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n    assertArgument(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n    fragment.inputs.forEach((param, index) => {\n      const value = values[index];\n      if (param.indexed) {\n        if (param.type === \"string\") {\n          topics.push(id(value));\n        } else if (param.type === \"bytes\") {\n          topics.push(keccak256(value));\n        } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n          // @TODO\n          throw new Error(\"not implemented\");\n        } else {\n          topics.push(_classPrivateFieldGet(_abiCoder, this).encode([param.type], [value]));\n        }\n      } else {\n        dataTypes.push(param);\n        dataValues.push(value);\n      }\n    });\n    return {\n      data: _classPrivateFieldGet(_abiCoder, this).encode(dataTypes, dataValues),\n      topics: topics\n    };\n  }\n  // Decode a filter for the event and the search criteria\n  decodeEventLog(fragment, data, topics) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n    if (topics != null && !fragment.anonymous) {\n      const eventTopic = fragment.topicHash;\n      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n      topics = topics.slice(1);\n    }\n    const indexed = [];\n    const nonIndexed = [];\n    const dynamic = [];\n    fragment.inputs.forEach((param, index) => {\n      if (param.indexed) {\n        if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n          indexed.push(ParamType.from({\n            type: \"bytes32\",\n            name: param.name\n          }));\n          dynamic.push(true);\n        } else {\n          indexed.push(param);\n          dynamic.push(false);\n        }\n      } else {\n        nonIndexed.push(param);\n        dynamic.push(false);\n      }\n    });\n    const resultIndexed = topics != null ? _classPrivateFieldGet(_abiCoder, this).decode(indexed, concat(topics)) : null;\n    const resultNonIndexed = _classPrivateFieldGet(_abiCoder, this).decode(nonIndexed, data, true);\n    //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n    const values = [];\n    const keys = [];\n    let nonIndexedIndex = 0,\n      indexedIndex = 0;\n    fragment.inputs.forEach((param, index) => {\n      let value = null;\n      if (param.indexed) {\n        if (resultIndexed == null) {\n          value = new Indexed(null);\n        } else if (dynamic[index]) {\n          value = new Indexed(resultIndexed[indexedIndex++]);\n        } else {\n          try {\n            value = resultIndexed[indexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n      } else {\n        try {\n          value = resultNonIndexed[nonIndexedIndex++];\n        } catch (error) {\n          value = error;\n        }\n      }\n      values.push(value);\n      keys.push(param.name || null);\n    });\n    return Result.fromItems(values, keys);\n  }\n  /**\n   *  Parses a transaction, finding the matching function and extracts\n   *  the parameter values along with other useful function details.\n   *\n   *  If the matching function cannot be found, return null.\n   */\n  parseTransaction(tx) {\n    const data = getBytes(tx.data, \"tx.data\");\n    const value = getBigInt(tx.value != null ? tx.value : 0, \"tx.value\");\n    const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, data.slice(4));\n    return new TransactionDescription(fragment, fragment.selector, args, value);\n  }\n  parseCallResult(data) {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Parses a receipt log, finding the matching event and extracts\n   *  the parameter values along with other useful event details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n  parseLog(log) {\n    const fragment = this.getEvent(log.topics[0]);\n    if (!fragment || fragment.anonymous) {\n      return null;\n    }\n    // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n    //        Probably not, because just because it is the only event in the ABI does\n    //        not mean we have the full ABI; maybe just a fragment?\n    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n  }\n  /**\n   *  Parses a revert data, finding the matching error and extracts\n   *  the parameter values along with other useful error details.\n   *\n   *  If the matching error cannot be found, returns null.\n   */\n  parseError(data) {\n    const hexData = hexlify(data);\n    const fragment = this.getError(dataSlice(hexData, 0, 4));\n    if (!fragment) {\n      return null;\n    }\n    const args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, dataSlice(hexData, 4));\n    return new ErrorDescription(fragment, fragment.selector, args);\n  }\n  /**\n   *  Creates a new [[Interface]] from the ABI %%value%%.\n   *\n   *  The %%value%% may be provided as an existing [[Interface]] object,\n   *  a JSON-encoded ABI or any Human-Readable ABI format.\n   */\n  static from(value) {\n    // Already an Interface, which is immutable\n    if (value instanceof Interface) {\n      return value;\n    }\n    // JSON\n    if (typeof value === \"string\") {\n      return new Interface(JSON.parse(value));\n    }\n    // An Interface; possibly from another v6 instance\n    if (typeof value.formatJson === \"function\") {\n      return new Interface(value.formatJson());\n    }\n    // A legacy Interface; from an older version\n    if (typeof value.format === \"function\") {\n      return new Interface(value.format(\"json\"));\n    }\n    // Array of fragments\n    return new Interface(value);\n  }\n}\n//# sourceMappingURL=interface.js.map\nfunction _getFunction(key, values, forceUnique) {\n  // Selector\n  if (isHexString(key)) {\n    const selector = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(_functions, this).values()) {\n      if (selector === fragment.selector) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(_functions, this)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      const lastValue = values.length > 0 ? values[values.length - 1] : null;\n      let valueLength = values.length;\n      let allowOptions = true;\n      if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n        allowOptions = false;\n        valueLength--;\n      }\n      // Remove all matches that don't have a compatible length. The args\n      // may contain an overrides, so the match may have n or n - 1 parameters\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs.length;\n        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // We are past the inputs\n          if (j >= inputs.length) {\n            if (values[j].type === \"overrides\") {\n              continue;\n            }\n            matching.splice(i, 1);\n            break;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    // We found a single matching signature with an overrides, but the\n    // last value is something that cannot possibly be an options\n    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n      const lastArg = values[values.length - 1];\n      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n        matching.splice(0, 1);\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      assertArgument(false, \"ambiguous function description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(_functions, this).get(FunctionFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nfunction _getEvent(key, values, forceUnique) {\n  // EventTopic\n  if (isHexString(key)) {\n    const eventTopic = key.toLowerCase();\n    for (const fragment of _classPrivateFieldGet(_events, this).values()) {\n      if (eventTopic === fragment.topicHash) {\n        return fragment;\n      }\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    const matching = [];\n    for (const [name, fragment] of _classPrivateFieldGet(_events, this)) {\n      if (name.split(\"(\" /* fix:) */)[0] === key) {\n        matching.push(fragment);\n      }\n    }\n    if (values) {\n      // Remove all matches that don't have a compatible length.\n      for (let i = matching.length - 1; i >= 0; i--) {\n        if (matching[i].inputs.length < values.length) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (let i = matching.length - 1; i >= 0; i--) {\n        const inputs = matching[i].inputs;\n        for (let j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n      assertArgument(false, \"ambiguous event description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  const result = _classPrivateFieldGet(_events, this).get(EventFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}