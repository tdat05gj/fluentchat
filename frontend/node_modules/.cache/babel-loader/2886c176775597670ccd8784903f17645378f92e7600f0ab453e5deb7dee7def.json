{"ast":null,"code":"import _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport { defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  assertNormalize(\"NFKD\");\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n  const words = wordlist.split(mnemonic);\n  assertArgument(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n  const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n  let offset = 0;\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    assertArgument(index >= 0, \"invalid mnemonic word at index \".concat(i), \"mnemonic\", \"[ REDACTED ]\");\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset++;\n    }\n  }\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n  const indices = [0];\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nexport class Mnemonic {\n  /**\n   *  @private\n   */\n  constructor(guard, entropy, phrase, password, wordlist) {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    _defineProperty(this, \"phrase\", void 0);\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    _defineProperty(this, \"password\", void 0);\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    _defineProperty(this, \"wordlist\", void 0);\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    _defineProperty(this, \"entropy\", void 0);\n    if (password == null) {\n      password = \"\";\n    }\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n    assertPrivate(guard, _guard, \"Mnemonic\");\n    defineProperties(this, {\n      phrase,\n      password,\n      wordlist,\n      entropy\n    });\n  }\n  /**\n   *  Returns the seed for the mnemonic.\n   */\n  computeSeed() {\n    const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n    return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n  }\n  /**\n   *  Creates a new Mnemonic for the %%phrase%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromPhrase(phrase, password, wordlist) {\n    // Normalize the case and space; throws if invalid\n    const entropy = mnemonicToEntropy(phrase, wordlist);\n    phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n    return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n  }\n  /**\n   *  Create a new **Mnemonic** from the %%entropy%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromEntropy(_entropy, password, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    const phrase = entropyToMnemonic(entropy, wordlist);\n    return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n  }\n  /**\n   *  Returns the phrase for %%mnemonic%%.\n   */\n  static entropyToPhrase(_entropy, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    return entropyToMnemonic(entropy, wordlist);\n  }\n  /**\n   *  Returns the entropy for %%phrase%%.\n   */\n  static phraseToEntropy(phrase, wordlist) {\n    return mnemonicToEntropy(phrase, wordlist);\n  }\n  /**\n   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n   *\n   *  This checks all the provided words belong to the %%wordlist%%,\n   *  that the length is valid and the checksum is correct.\n   */\n  static isValidMnemonic(phrase, wordlist) {\n    try {\n      mnemonicToEntropy(phrase, wordlist);\n      return true;\n    } catch (error) {}\n    return false;\n  }\n}\n//# sourceMappingURL=mnemonic.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}