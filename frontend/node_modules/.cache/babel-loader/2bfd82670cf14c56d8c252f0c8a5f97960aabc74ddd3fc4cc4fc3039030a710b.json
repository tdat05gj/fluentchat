{"ast":null,"code":"import _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument, makeError } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filter = /*#__PURE__*/new WeakMap();\nvar _filterId = /*#__PURE__*/new WeakMap();\nvar _paused = /*#__PURE__*/new WeakMap();\nvar _emitPromise = /*#__PURE__*/new WeakMap();\nexport class SocketSubscriber {\n  /**\n   *  The filter.\n   */\n  get filter() {\n    return JSON.parse(_classPrivateFieldGet(_filter, this));\n  }\n  /**\n   *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n   *  to %%filter%%.\n   */\n  constructor(provider, filter) {\n    _classPrivateFieldInitSpec(this, _provider, void 0);\n    _classPrivateFieldInitSpec(this, _filter, void 0);\n    _classPrivateFieldInitSpec(this, _filterId, void 0);\n    _classPrivateFieldInitSpec(this, _paused, void 0);\n    _classPrivateFieldInitSpec(this, _emitPromise, void 0);\n    _classPrivateFieldSet(_provider, this, provider);\n    _classPrivateFieldSet(_filter, this, JSON.stringify(filter));\n    _classPrivateFieldSet(_filterId, this, null);\n    _classPrivateFieldSet(_paused, this, null);\n    _classPrivateFieldSet(_emitPromise, this, null);\n  }\n  start() {\n    _classPrivateFieldSet(_filterId, this, _classPrivateFieldGet(_provider, this).send(\"eth_subscribe\", this.filter).then(filterId => {\n      ;\n      _classPrivateFieldGet(_provider, this)._register(filterId, this);\n      return filterId;\n    }));\n  }\n  stop() {\n    _classPrivateFieldGet(_filterId, this).then(filterId => {\n      if (_classPrivateFieldGet(_provider, this).destroyed) {\n        return;\n      }\n      _classPrivateFieldGet(_provider, this).send(\"eth_unsubscribe\", [filterId]);\n    });\n    _classPrivateFieldSet(_filterId, this, null);\n  }\n  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n  //        and resume\n  pause(dropWhilePaused) {\n    assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"pause(false)\"\n    });\n    _classPrivateFieldSet(_paused, this, !!dropWhilePaused);\n  }\n  resume() {\n    _classPrivateFieldSet(_paused, this, null);\n  }\n  /**\n   *  @_ignore:\n   */\n  _handleMessage(message) {\n    if (_classPrivateFieldGet(_filterId, this) == null) {\n      return;\n    }\n    if (_classPrivateFieldGet(_paused, this) === null) {\n      let emitPromise = _classPrivateFieldGet(_emitPromise, this);\n      if (emitPromise == null) {\n        emitPromise = this._emit(_classPrivateFieldGet(_provider, this), message);\n      } else {\n        emitPromise = emitPromise.then(async () => {\n          await this._emit(_classPrivateFieldGet(_provider, this), message);\n        });\n      }\n      _classPrivateFieldSet(_emitPromise, this, emitPromise.then(() => {\n        if (_classPrivateFieldGet(_emitPromise, this) === emitPromise) {\n          _classPrivateFieldSet(_emitPromise, this, null);\n        }\n      }));\n    }\n  }\n  /**\n   *  Sub-classes **must** override this to emit the events on the\n   *  provider.\n   */\n  async _emit(provider, message) {\n    throw new Error(\"sub-classes must implemente this; _emit\");\n  }\n}\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */\nexport class SocketBlockSubscriber extends SocketSubscriber {\n  /**\n   *  @_ignore:\n   */\n  constructor(provider) {\n    super(provider, [\"newHeads\"]);\n  }\n  async _emit(provider, message) {\n    provider.emit(\"block\", parseInt(message.number));\n  }\n}\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */\nexport class SocketPendingSubscriber extends SocketSubscriber {\n  /**\n   *  @_ignore:\n   */\n  constructor(provider) {\n    super(provider, [\"newPendingTransactions\"]);\n  }\n  async _emit(provider, message) {\n    provider.emit(\"pending\", message);\n  }\n}\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */\nvar _logFilter = /*#__PURE__*/new WeakMap();\nexport class SocketEventSubscriber extends SocketSubscriber {\n  /**\n   *  The filter.\n   */\n  get logFilter() {\n    return JSON.parse(_classPrivateFieldGet(_logFilter, this));\n  }\n  /**\n   *  @_ignore:\n   */\n  constructor(provider, filter) {\n    super(provider, [\"logs\", filter]);\n    _classPrivateFieldInitSpec(this, _logFilter, void 0);\n    _classPrivateFieldSet(_logFilter, this, JSON.stringify(filter));\n  }\n  async _emit(provider, message) {\n    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n  }\n}\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */\nvar _callbacks = /*#__PURE__*/new WeakMap();\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _pending = /*#__PURE__*/new WeakMap();\nexport class SocketProvider extends JsonRpcApiProvider {\n  /**\n   *  Creates a new **SocketProvider** connected to %%network%%.\n   *\n   *  If unspecified, the network will be discovered.\n   */\n  constructor(network, _options) {\n    // Copy the options\n    const options = Object.assign({}, _options != null ? _options : {});\n    // Support for batches is generally not supported for\n    // connection-base providers; if this changes in the future\n    // the _send should be updated to reflect this\n    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, \"sockets-based providers do not support batches\", \"options.batchMaxCount\", _options);\n    options.batchMaxCount = 1;\n    // Socket-based Providers (generally) cannot change their network,\n    // since they have a long-lived connection; but let people override\n    // this if they have just cause.\n    if (options.staticNetwork == null) {\n      options.staticNetwork = true;\n    }\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _callbacks, void 0);\n    // Maps each filterId to its subscriber\n    _classPrivateFieldInitSpec(this, _subs, void 0);\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    _classPrivateFieldInitSpec(this, _pending, void 0);\n    _classPrivateFieldSet(_callbacks, this, new Map());\n    _classPrivateFieldSet(_subs, this, new Map());\n    _classPrivateFieldSet(_pending, this, new Map());\n  }\n  // This value is only valid after _start has been called\n  /*\n  get _network(): Network {\n      if (this.#network == null) {\n          throw new Error(\"this shouldn't happen\");\n      }\n      return this.#network.clone();\n  }\n  */\n  _getSubscriber(sub) {\n    switch (sub.type) {\n      case \"close\":\n        return new UnmanagedSubscriber(\"close\");\n      case \"block\":\n        return new SocketBlockSubscriber(this);\n      case \"pending\":\n        return new SocketPendingSubscriber(this);\n      case \"event\":\n        return new SocketEventSubscriber(this, sub.filter);\n      case \"orphan\":\n        // Handled auto-matically within AbstractProvider\n        // when the log.removed = true\n        if (sub.filter.orphan === \"drop-log\") {\n          return new UnmanagedSubscriber(\"drop-log\");\n        }\n    }\n    return super._getSubscriber(sub);\n  }\n  /**\n   *  Register a new subscriber. This is used internalled by Subscribers\n   *  and generally is unecessary unless extending capabilities.\n   */\n  _register(filterId, subscriber) {\n    _classPrivateFieldGet(_subs, this).set(filterId, subscriber);\n    const pending = _classPrivateFieldGet(_pending, this).get(filterId);\n    if (pending) {\n      for (const message of pending) {\n        subscriber._handleMessage(message);\n      }\n      _classPrivateFieldGet(_pending, this).delete(filterId);\n    }\n  }\n  async _send(payload) {\n    // WebSocket provider doesn't accept batches\n    assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n    // @TODO: stringify payloads here and store to prevent mutations\n    // Prepare a promise to respond to\n    const promise = new Promise((resolve, reject) => {\n      _classPrivateFieldGet(_callbacks, this).set(payload.id, {\n        payload,\n        resolve,\n        reject\n      });\n    });\n    // Wait until the socket is connected before writing to it\n    await this._waitUntilReady();\n    // Write the request to the socket\n    await this._write(JSON.stringify(payload));\n    return [await promise];\n  }\n  // Sub-classes must call this once they are connected\n  /*\n  async _start(): Promise<void> {\n      if (this.#ready) { return; }\n       for (const { payload } of this.#callbacks.values()) {\n          await this._write(JSON.stringify(payload));\n      }\n       this.#ready = (async function() {\n          await super._start();\n      })();\n  }\n  */\n  /**\n   *  Sub-classes **must** call this with messages received over their\n   *  transport to be processed and dispatched.\n   */\n  async _processMessage(message) {\n    const result = JSON.parse(message);\n    if (result && typeof result === \"object\" && \"id\" in result) {\n      const callback = _classPrivateFieldGet(_callbacks, this).get(result.id);\n      if (callback == null) {\n        this.emit(\"error\", makeError(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n          reasonCode: \"UNKNOWN_ID\",\n          result\n        }));\n        return;\n      }\n      _classPrivateFieldGet(_callbacks, this).delete(result.id);\n      callback.resolve(result);\n    } else if (result && result.method === \"eth_subscription\") {\n      const filterId = result.params.subscription;\n      const subscriber = _classPrivateFieldGet(_subs, this).get(filterId);\n      if (subscriber) {\n        subscriber._handleMessage(result.params.result);\n      } else {\n        let pending = _classPrivateFieldGet(_pending, this).get(filterId);\n        if (pending == null) {\n          pending = [];\n          _classPrivateFieldGet(_pending, this).set(filterId, pending);\n        }\n        pending.push(result.params.result);\n      }\n    } else {\n      this.emit(\"error\", makeError(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n        reasonCode: \"UNEXPECTED_MESSAGE\",\n        result\n      }));\n      return;\n    }\n  }\n  /**\n   *  Sub-classes **must** override this to send %%message%% over their\n   *  transport.\n   */\n  async _write(message) {\n    throw new Error(\"sub-classes must override this\");\n  }\n}\n//# sourceMappingURL=provider-socket.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}