{"ast":null,"code":"//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\nfunction hexlifyByte(value) {\n  let result = value.toString(16);\n  while (result.length < 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    assert(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length,\n      offset\n    });\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n    buffer: data,\n    length: 0,\n    offset: 1\n  });\n  const checkOffset = offset => {\n    assert(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: data.length,\n      offset\n    });\n  };\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    checkOffset(offset + 1 + length);\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    checkOffset(offset + 1 + length);\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlifyByte(data[offset])\n  };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nexport function decodeRlp(_data) {\n  const data = getBytes(_data, \"data\");\n  const decoded = _decode(data, 0);\n  assertArgument(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n  return decoded.result;\n}\n//# sourceMappingURL=rlp-decode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}