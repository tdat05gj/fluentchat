{"ast":null,"code":"import _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */\nimport { accessListify } from \"../transaction/index.js\";\nimport { getBigInt, assert, assertArgument } from \"../utils/index.js\";\nimport { EnsPlugin, FetchUrlFeeDataNetworkPlugin, GasCostPlugin } from \"./plugins-network.js\";\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/\nconst Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */\nvar _name = /*#__PURE__*/new WeakMap();\nvar _chainId = /*#__PURE__*/new WeakMap();\nvar _plugins = /*#__PURE__*/new WeakMap();\nexport class Network {\n  /**\n   *  Creates a new **Network** for %%name%% and %%chainId%%.\n   */\n  constructor(name, chainId) {\n    _classPrivateFieldInitSpec(this, _name, void 0);\n    _classPrivateFieldInitSpec(this, _chainId, void 0);\n    _classPrivateFieldInitSpec(this, _plugins, void 0);\n    _classPrivateFieldSet(_name, this, name);\n    _classPrivateFieldSet(_chainId, this, getBigInt(chainId));\n    _classPrivateFieldSet(_plugins, this, new Map());\n  }\n  /**\n   *  Returns a JSON-compatible representation of a Network.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      chainId: String(this.chainId)\n    };\n  }\n  /**\n   *  The network common name.\n   *\n   *  This is the canonical name, as networks migh have multiple\n   *  names.\n   */\n  get name() {\n    return _classPrivateFieldGet(_name, this);\n  }\n  set name(value) {\n    _classPrivateFieldSet(_name, this, value);\n  }\n  /**\n   *  The network chain ID.\n   */\n  get chainId() {\n    return _classPrivateFieldGet(_chainId, this);\n  }\n  set chainId(value) {\n    _classPrivateFieldSet(_chainId, this, getBigInt(value, \"chainId\"));\n  }\n  /**\n   *  Returns true if %%other%% matches this network. Any chain ID\n   *  must match, and if no chain ID is present, the name must match.\n   *\n   *  This method does not currently check for additional properties,\n   *  such as ENS address or plug-in compatibility.\n   */\n  matches(other) {\n    if (other == null) {\n      return false;\n    }\n    if (typeof other === \"string\") {\n      try {\n        return this.chainId === getBigInt(other);\n      } catch (error) {}\n      return this.name === other;\n    }\n    if (typeof other === \"number\" || typeof other === \"bigint\") {\n      try {\n        return this.chainId === getBigInt(other);\n      } catch (error) {}\n      return false;\n    }\n    if (typeof other === \"object\") {\n      if (other.chainId != null) {\n        try {\n          return this.chainId === getBigInt(other.chainId);\n        } catch (error) {}\n        return false;\n      }\n      if (other.name != null) {\n        return this.name === other.name;\n      }\n      return false;\n    }\n    return false;\n  }\n  /**\n   *  Returns the list of plugins currently attached to this Network.\n   */\n  get plugins() {\n    return Array.from(_classPrivateFieldGet(_plugins, this).values());\n  }\n  /**\n   *  Attach a new %%plugin%% to this Network. The network name\n   *  must be unique, excluding any fragment.\n   */\n  attachPlugin(plugin) {\n    if (_classPrivateFieldGet(_plugins, this).get(plugin.name)) {\n      throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n    }\n    _classPrivateFieldGet(_plugins, this).set(plugin.name, plugin.clone());\n    return this;\n  }\n  /**\n   *  Return the plugin, if any, matching %%name%% exactly. Plugins\n   *  with fragments will not be returned unless %%name%% includes\n   *  a fragment.\n   */\n  getPlugin(name) {\n    return _classPrivateFieldGet(_plugins, this).get(name) || null;\n  }\n  /**\n   *  Gets a list of all plugins that match %%name%%, with otr without\n   *  a fragment.\n   */\n  getPlugins(basename) {\n    return this.plugins.filter(p => p.name.split(\"#\")[0] === basename);\n  }\n  /**\n   *  Create a copy of this Network.\n   */\n  clone() {\n    const clone = new Network(this.name, this.chainId);\n    this.plugins.forEach(plugin => {\n      clone.attachPlugin(plugin.clone());\n    });\n    return clone;\n  }\n  /**\n   *  Compute the intrinsic gas required for a transaction.\n   *\n   *  A GasCostPlugin can be attached to override the default\n   *  values.\n   */\n  computeIntrinsicGas(tx) {\n    const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new GasCostPlugin();\n    let gas = costs.txBase;\n    if (tx.to == null) {\n      gas += costs.txCreate;\n    }\n    if (tx.data) {\n      for (let i = 2; i < tx.data.length; i += 2) {\n        if (tx.data.substring(i, i + 2) === \"00\") {\n          gas += costs.txDataZero;\n        } else {\n          gas += costs.txDataNonzero;\n        }\n      }\n    }\n    if (tx.accessList) {\n      const accessList = accessListify(tx.accessList);\n      for (const addr in accessList) {\n        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n      }\n    }\n    return gas;\n  }\n  /**\n   *  Returns a new Network for the %%network%% name or chainId.\n   */\n  static from(network) {\n    injectCommonNetworks();\n    // Default network\n    if (network == null) {\n      return Network.from(\"mainnet\");\n    }\n    // Canonical name or chain ID\n    if (typeof network === \"number\") {\n      network = BigInt(network);\n    }\n    if (typeof network === \"string\" || typeof network === \"bigint\") {\n      const networkFunc = Networks.get(network);\n      if (networkFunc) {\n        return networkFunc();\n      }\n      if (typeof network === \"bigint\") {\n        return new Network(\"unknown\", network);\n      }\n      assertArgument(false, \"unknown network\", \"network\", network);\n    }\n    // Clonable with network-like abilities\n    if (typeof network.clone === \"function\") {\n      const clone = network.clone();\n      //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n      //}\n      return clone;\n    }\n    // Networkish\n    if (typeof network === \"object\") {\n      assertArgument(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n      const custom = new Network(network.name, network.chainId);\n      if (network.ensAddress || network.ensNetwork != null) {\n        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));\n      }\n      //if ((<any>network).layerOneConnection) {\n      //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n      //}\n      return custom;\n    }\n    assertArgument(false, \"invalid network\", \"network\", network);\n  }\n  /**\n   *  Register %%nameOrChainId%% with a function which returns\n   *  an instance of a Network representing that chain.\n   */\n  static register(nameOrChainId, networkFunc) {\n    if (typeof nameOrChainId === \"number\") {\n      nameOrChainId = BigInt(nameOrChainId);\n    }\n    const existing = Networks.get(nameOrChainId);\n    if (existing) {\n      assertArgument(false, \"conflicting network for \".concat(JSON.stringify(existing.name)), \"nameOrChainId\", nameOrChainId);\n    }\n    Networks.set(nameOrChainId, networkFunc);\n  }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n  const value = String(_value);\n  if (!value.match(/^[0-9.]+$/)) {\n    throw new Error(\"invalid gwei value: \".concat(_value));\n  }\n  // Break into [ whole, fraction ]\n  const comps = value.split(\".\");\n  if (comps.length === 1) {\n    comps.push(\"\");\n  }\n  // More than 1 decimal point or too many fractional positions\n  if (comps.length !== 2) {\n    throw new Error(\"invalid gwei value: \".concat(_value));\n  }\n  // Pad the fraction to 9 decimalplaces\n  while (comps[1].length < decimals) {\n    comps[1] += \"0\";\n  }\n  // Too many decimals and some non-zero ending, take the ceiling\n  if (comps[1].length > 9) {\n    let frac = BigInt(comps[1].substring(0, 9));\n    if (!comps[1].substring(9).match(/^0+$/)) {\n      frac++;\n    }\n    comps[1] = frac.toString();\n  }\n  return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\n    // Prevent Cloudflare from blocking our request in node.js\n    request.setHeader(\"User-Agent\", \"ethers\");\n    let response;\n    try {\n      const [_response, _feeData] = await Promise.all([request.send(), fetchFeeData()]);\n      response = _response;\n      const payload = response.bodyJson.standard;\n      const feeData = {\n        gasPrice: _feeData.gasPrice,\n        maxFeePerGas: parseUnits(payload.maxFee, 9),\n        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n      };\n      return feeData;\n    } catch (error) {\n      assert(false, \"error encountered with polygon gas station (\".concat(JSON.stringify(request.url), \")\"), \"SERVER_ERROR\", {\n        request,\n        response,\n        error\n      });\n    }\n  });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n  if (injected) {\n    return;\n  }\n  injected = true;\n  /// Register popular Ethereum networks\n  function registerEth(name, chainId, options) {\n    const func = function () {\n      const network = new Network(name, chainId);\n      // We use 0 to disable ENS\n      if (options.ensNetwork != null) {\n        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));\n      }\n      network.attachPlugin(new GasCostPlugin());\n      (options.plugins || []).forEach(plugin => {\n        network.attachPlugin(plugin);\n      });\n      return network;\n    };\n    // Register the network by name and chain ID\n    Network.register(name, func);\n    Network.register(chainId, func);\n    if (options.altNames) {\n      options.altNames.forEach(name => {\n        Network.register(name, func);\n      });\n    }\n  }\n  registerEth(\"mainnet\", 1, {\n    ensNetwork: 1,\n    altNames: [\"homestead\"]\n  });\n  registerEth(\"ropsten\", 3, {\n    ensNetwork: 3\n  });\n  registerEth(\"rinkeby\", 4, {\n    ensNetwork: 4\n  });\n  registerEth(\"goerli\", 5, {\n    ensNetwork: 5\n  });\n  registerEth(\"kovan\", 42, {\n    ensNetwork: 42\n  });\n  registerEth(\"sepolia\", 11155111, {\n    ensNetwork: 11155111\n  });\n  registerEth(\"holesky\", 17000, {\n    ensNetwork: 17000\n  });\n  registerEth(\"classic\", 61, {});\n  registerEth(\"classicKotti\", 6, {});\n  registerEth(\"arbitrum\", 42161, {\n    ensNetwork: 1\n  });\n  registerEth(\"arbitrum-goerli\", 421613, {});\n  registerEth(\"arbitrum-sepolia\", 421614, {});\n  registerEth(\"base\", 8453, {\n    ensNetwork: 1\n  });\n  registerEth(\"base-goerli\", 84531, {});\n  registerEth(\"base-sepolia\", 84532, {});\n  registerEth(\"bnb\", 56, {\n    ensNetwork: 1\n  });\n  registerEth(\"bnbt\", 97, {});\n  registerEth(\"linea\", 59144, {\n    ensNetwork: 1\n  });\n  registerEth(\"linea-goerli\", 59140, {});\n  registerEth(\"linea-sepolia\", 59141, {});\n  registerEth(\"matic\", 137, {\n    ensNetwork: 1,\n    plugins: [getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")]\n  });\n  registerEth(\"matic-amoy\", 80002, {});\n  registerEth(\"matic-mumbai\", 80001, {\n    altNames: [\"maticMumbai\", \"maticmum\"],\n    plugins: [getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")]\n  });\n  registerEth(\"optimism\", 10, {\n    ensNetwork: 1,\n    plugins: []\n  });\n  registerEth(\"optimism-goerli\", 420, {});\n  registerEth(\"optimism-sepolia\", 11155420, {});\n  registerEth(\"xdai\", 100, {\n    ensNetwork: 1\n  });\n}\n//# sourceMappingURL=network.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}