{"ast":null,"code":"import { keccak256 } from \"../crypto/index.js\";\nimport { concat, hexlify, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nimport { ens_normalize } from \"@adraffy/ens-normalize\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n  assertArgument(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n  return comp;\n}\nfunction ensNameSplit(name) {\n  const bytes = toUtf8Bytes(ensNormalize(name));\n  const comps = [];\n  if (name.length === 0) {\n    return comps;\n  }\n  let last = 0;\n  for (let i = 0; i < bytes.length; i++) {\n    const d = bytes[i];\n    // A separator (i.e. \".\"); copy this component\n    if (d === 0x2e) {\n      comps.push(checkComponent(bytes.slice(last, i)));\n      last = i + 1;\n    }\n  }\n  // There was a stray separator at the end of the name\n  assertArgument(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n  comps.push(checkComponent(bytes.slice(last)));\n  return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nexport function ensNormalize(name) {\n  try {\n    if (name.length === 0) {\n      throw new Error(\"empty label\");\n    }\n    return ens_normalize(name);\n  } catch (error) {\n    assertArgument(false, \"invalid ENS name (\".concat(error.message, \")\"), \"name\", name);\n  }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nexport function isValidName(name) {\n  try {\n    return ensNameSplit(name).length !== 0;\n  } catch (error) {}\n  return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nexport function namehash(name) {\n  assertArgument(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n  assertArgument(name.length, \"invalid ENS name (empty label)\", \"name\", name);\n  let result = Zeros;\n  const comps = ensNameSplit(name);\n  while (comps.length) {\n    result = keccak256(concat([result, keccak256(comps.pop())]));\n  }\n  return hexlify(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nexport function dnsEncode(name, _maxLength) {\n  const length = _maxLength != null ? _maxLength : 63;\n  assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n  return hexlify(concat(ensNameSplit(name).map(comp => {\n    assertArgument(comp.length <= length, \"label \".concat(JSON.stringify(name), \" exceeds \").concat(length, \" bytes\"), \"name\", name);\n    const bytes = new Uint8Array(comp.length + 1);\n    bytes.set(comp, 1);\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}