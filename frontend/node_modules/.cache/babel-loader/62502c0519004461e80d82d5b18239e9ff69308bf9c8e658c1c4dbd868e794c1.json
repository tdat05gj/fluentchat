{"ast":null,"code":"import _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashAuthorization, hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nvar _signingKey = /*#__PURE__*/new WeakMap();\nexport class BaseWallet extends AbstractSigner {\n  /**\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\n   *  connected to %%provider%%.\n   *\n   *  If %%provider%% is not specified, only offline methods can\n   *  be used.\n   */\n  constructor(privateKey, provider) {\n    super(provider);\n    /**\n     *  The wallet address.\n     */\n    _defineProperty(this, \"address\", void 0);\n    _classPrivateFieldInitSpec(this, _signingKey, void 0);\n    assertArgument(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    _classPrivateFieldSet(_signingKey, this, privateKey);\n    const address = computeAddress(this.signingKey.publicKey);\n    defineProperties(this, {\n      address\n    });\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\n   *  The [[SigningKey]] used for signing payloads.\n   */\n  get signingKey() {\n    return _classPrivateFieldGet(_signingKey, this);\n  }\n  /**\n   *  The private key for this wallet.\n   */\n  get privateKey() {\n    return this.signingKey.privateKey;\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new BaseWallet(_classPrivateFieldGet(_signingKey, this), provider);\n  }\n  async signTransaction(tx) {\n    tx = copyRequest(tx);\n    // Replace any Addressable or ENS name with an address\n    const {\n      to,\n      from\n    } = await resolveProperties({\n      to: tx.to ? resolveAddress(tx.to, this) : undefined,\n      from: tx.from ? resolveAddress(tx.from, this) : undefined\n    });\n    if (to != null) {\n      tx.to = to;\n    }\n    if (from != null) {\n      tx.from = from;\n    }\n    if (tx.from != null) {\n      assertArgument(getAddress(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n      delete tx.from;\n    }\n    // Build the transaction\n    const btx = Transaction.from(tx);\n    btx.signature = this.signingKey.sign(btx.unsignedHash);\n    return btx.serialized;\n  }\n  async signMessage(message) {\n    return this.signMessageSync(message);\n  }\n  // @TODO: Add a secialized signTx and signTyped sync that enforces\n  // all parameters are known?\n  /**\n   *  Returns the signature for %%message%% signed with this wallet.\n   */\n  signMessageSync(message) {\n    return this.signingKey.sign(hashMessage(message)).serialized;\n  }\n  /**\n   *  Returns the Authorization for %%auth%%.\n   */\n  authorizeSync(auth) {\n    assertArgument(typeof auth.address === \"string\", \"invalid address for authorizeSync\", \"auth.address\", auth);\n    const signature = this.signingKey.sign(hashAuthorization(auth));\n    return Object.assign({}, {\n      address: getAddress(auth.address),\n      nonce: getBigInt(auth.nonce || 0),\n      chainId: getBigInt(auth.chainId || 0)\n    }, {\n      signature\n    });\n  }\n  /**\n   *  Resolves to the Authorization for %%auth%%.\n   */\n  async authorize(auth) {\n    auth = Object.assign({}, auth, {\n      address: await resolveAddress(auth.address, this)\n    });\n    return this.authorizeSync(await this.populateAuthorization(auth));\n  }\n  async signTypedData(domain, types, value) {\n    // Populate any ENS names\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async name => {\n      // @TODO: this should use resolveName; addresses don't\n      //        need a provider\n      assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"resolveName\",\n        info: {\n          name\n        }\n      });\n      const address = await this.provider.resolveName(name);\n      assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n        value: name\n      });\n      return address;\n    });\n    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n  }\n}\n//# sourceMappingURL=base-wallet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}