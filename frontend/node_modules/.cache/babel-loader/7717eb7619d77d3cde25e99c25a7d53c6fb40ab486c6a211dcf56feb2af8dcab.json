{"ast":null,"code":"import _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nvar _noncePromise = /*#__PURE__*/new WeakMap();\nvar _delta = /*#__PURE__*/new WeakMap();\nexport class NonceManager extends AbstractSigner {\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  constructor(signer) {\n    super(signer.provider);\n    /**\n     *  The Signer being managed.\n     */\n    _defineProperty(this, \"signer\", void 0);\n    _classPrivateFieldInitSpec(this, _noncePromise, void 0);\n    _classPrivateFieldInitSpec(this, _delta, void 0);\n    defineProperties(this, {\n      signer\n    });\n    _classPrivateFieldSet(_noncePromise, this, null);\n    _classPrivateFieldSet(_delta, this, 0);\n  }\n  async getAddress() {\n    return this.signer.getAddress();\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  async getNonce(blockTag) {\n    if (blockTag === \"pending\") {\n      if (_classPrivateFieldGet(_noncePromise, this) == null) {\n        _classPrivateFieldSet(_noncePromise, this, super.getNonce(\"pending\"));\n      }\n      const delta = _classPrivateFieldGet(_delta, this);\n      return (await _classPrivateFieldGet(_noncePromise, this)) + delta;\n    }\n    return super.getNonce(blockTag);\n  }\n  /**\n   *  Manually increment the nonce. This may be useful when managng\n   *  offline transactions.\n   */\n  increment() {\n    var _this$delta, _this$delta2;\n    _classPrivateFieldSet(_delta, this, (_this$delta = _classPrivateFieldGet(_delta, this), _this$delta2 = _this$delta++, _this$delta)), _this$delta2;\n  }\n  /**\n   *  Resets the nonce, causing the **NonceManager** to reload the current\n   *  nonce from the blockchain on the next transaction.\n   */\n  reset() {\n    _classPrivateFieldSet(_delta, this, 0);\n    _classPrivateFieldSet(_noncePromise, this, null);\n  }\n  async sendTransaction(tx) {\n    const noncePromise = this.getNonce(\"pending\");\n    this.increment();\n    tx = await this.signer.populateTransaction(tx);\n    tx.nonce = await noncePromise;\n    // @TODO: Maybe handle interesting/recoverable errors?\n    // Like don't increment if the tx was certainly not sent\n    return await this.signer.sendTransaction(tx);\n  }\n  signTransaction(tx) {\n    return this.signer.signTransaction(tx);\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n  }\n  signTypedData(domain, types, value) {\n    return this.signer.signTypedData(domain, types, value);\n  }\n}\n//# sourceMappingURL=signer-noncemanager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}