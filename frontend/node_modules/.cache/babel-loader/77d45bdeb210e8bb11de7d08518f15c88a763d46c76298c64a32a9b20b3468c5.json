{"ast":null,"code":"import _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\nconst _gaurd = {};\nfunction n(value, width) {\n  let signed = false;\n  if (width < 0) {\n    signed = true;\n    width *= -1;\n  }\n  // @TODO: Check range is valid for value\n  return new Typed(_gaurd, \"\".concat(signed ? \"\" : \"u\", \"int\").concat(width), value, {\n    signed,\n    width\n  });\n}\nfunction b(value, size) {\n  // @TODO: Check range is valid for value\n  return new Typed(_gaurd, \"bytes\".concat(size ? size : \"\"), value, {\n    size\n  });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nvar _options = /*#__PURE__*/new WeakMap();\nexport class Typed {\n  /**\n   *  @_ignore:\n   */\n  constructor(gaurd, type, value, options) {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    _defineProperty(this, \"type\", void 0);\n    /**\n     *  The actual value.\n     */\n    _defineProperty(this, \"value\", void 0);\n    _classPrivateFieldInitSpec(this, _options, void 0);\n    /**\n     *  @_ignore:\n     */\n    _defineProperty(this, \"_typedSymbol\", void 0);\n    if (options == null) {\n      options = null;\n    }\n    assertPrivate(_gaurd, gaurd, \"Typed\");\n    defineProperties(this, {\n      _typedSymbol,\n      type,\n      value\n    });\n    _classPrivateFieldSet(_options, this, options);\n    // Check the value is valid\n    this.format();\n  }\n  /**\n   *  Format the type as a Human-Readable type.\n   */\n  format() {\n    if (this.type === \"array\") {\n      throw new Error(\"\");\n    } else if (this.type === \"dynamicArray\") {\n      throw new Error(\"\");\n    } else if (this.type === \"tuple\") {\n      return \"tuple(\".concat(this.value.map(v => v.format()).join(\",\"), \")\");\n    }\n    return this.type;\n  }\n  /**\n   *  The default value returned by this type.\n   */\n  defaultValue() {\n    return 0;\n  }\n  /**\n   *  The minimum value for numeric types.\n   */\n  minValue() {\n    return 0;\n  }\n  /**\n   *  The maximum value for numeric types.\n   */\n  maxValue() {\n    return 0;\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n   */\n  isBigInt() {\n    return !!this.type.match(/^u?int[0-9]+$/);\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n   */\n  isData() {\n    return this.type.startsWith(\"bytes\");\n  }\n  /**\n   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n   */\n  isString() {\n    return this.type === \"string\";\n  }\n  /**\n   *  Returns the tuple name, if this is a tuple. Throws otherwise.\n   */\n  get tupleName() {\n    if (this.type !== \"tuple\") {\n      throw TypeError(\"not a tuple\");\n    }\n    return _classPrivateFieldGet(_options, this);\n  }\n  // Returns the length of this type as an array\n  // - `null` indicates the length is unforced, it could be dynamic\n  // - `-1` indicates the length is dynamic\n  // - any other value indicates it is a static array and is its length\n  /**\n   *  Returns the length of the array type or ``-1`` if it is dynamic.\n   *\n   *  Throws if the type is not an array.\n   */\n  get arrayLength() {\n    if (this.type !== \"array\") {\n      throw TypeError(\"not an array\");\n    }\n    if (_classPrivateFieldGet(_options, this) === true) {\n      return -1;\n    }\n    if (_classPrivateFieldGet(_options, this) === false) {\n      return this.value.length;\n    }\n    return null;\n  }\n  /**\n   *  Returns a new **Typed** of %%type%% with the %%value%%.\n   */\n  static from(type, value) {\n    return new Typed(_gaurd, type, value);\n  }\n  /**\n   *  Return a new ``uint8`` type for %%v%%.\n   */\n  static uint8(v) {\n    return n(v, 8);\n  }\n  /**\n   *  Return a new ``uint16`` type for %%v%%.\n   */\n  static uint16(v) {\n    return n(v, 16);\n  }\n  /**\n   *  Return a new ``uint24`` type for %%v%%.\n   */\n  static uint24(v) {\n    return n(v, 24);\n  }\n  /**\n   *  Return a new ``uint32`` type for %%v%%.\n   */\n  static uint32(v) {\n    return n(v, 32);\n  }\n  /**\n   *  Return a new ``uint40`` type for %%v%%.\n   */\n  static uint40(v) {\n    return n(v, 40);\n  }\n  /**\n   *  Return a new ``uint48`` type for %%v%%.\n   */\n  static uint48(v) {\n    return n(v, 48);\n  }\n  /**\n   *  Return a new ``uint56`` type for %%v%%.\n   */\n  static uint56(v) {\n    return n(v, 56);\n  }\n  /**\n   *  Return a new ``uint64`` type for %%v%%.\n   */\n  static uint64(v) {\n    return n(v, 64);\n  }\n  /**\n   *  Return a new ``uint72`` type for %%v%%.\n   */\n  static uint72(v) {\n    return n(v, 72);\n  }\n  /**\n   *  Return a new ``uint80`` type for %%v%%.\n   */\n  static uint80(v) {\n    return n(v, 80);\n  }\n  /**\n   *  Return a new ``uint88`` type for %%v%%.\n   */\n  static uint88(v) {\n    return n(v, 88);\n  }\n  /**\n   *  Return a new ``uint96`` type for %%v%%.\n   */\n  static uint96(v) {\n    return n(v, 96);\n  }\n  /**\n   *  Return a new ``uint104`` type for %%v%%.\n   */\n  static uint104(v) {\n    return n(v, 104);\n  }\n  /**\n   *  Return a new ``uint112`` type for %%v%%.\n   */\n  static uint112(v) {\n    return n(v, 112);\n  }\n  /**\n   *  Return a new ``uint120`` type for %%v%%.\n   */\n  static uint120(v) {\n    return n(v, 120);\n  }\n  /**\n   *  Return a new ``uint128`` type for %%v%%.\n   */\n  static uint128(v) {\n    return n(v, 128);\n  }\n  /**\n   *  Return a new ``uint136`` type for %%v%%.\n   */\n  static uint136(v) {\n    return n(v, 136);\n  }\n  /**\n   *  Return a new ``uint144`` type for %%v%%.\n   */\n  static uint144(v) {\n    return n(v, 144);\n  }\n  /**\n   *  Return a new ``uint152`` type for %%v%%.\n   */\n  static uint152(v) {\n    return n(v, 152);\n  }\n  /**\n   *  Return a new ``uint160`` type for %%v%%.\n   */\n  static uint160(v) {\n    return n(v, 160);\n  }\n  /**\n   *  Return a new ``uint168`` type for %%v%%.\n   */\n  static uint168(v) {\n    return n(v, 168);\n  }\n  /**\n   *  Return a new ``uint176`` type for %%v%%.\n   */\n  static uint176(v) {\n    return n(v, 176);\n  }\n  /**\n   *  Return a new ``uint184`` type for %%v%%.\n   */\n  static uint184(v) {\n    return n(v, 184);\n  }\n  /**\n   *  Return a new ``uint192`` type for %%v%%.\n   */\n  static uint192(v) {\n    return n(v, 192);\n  }\n  /**\n   *  Return a new ``uint200`` type for %%v%%.\n   */\n  static uint200(v) {\n    return n(v, 200);\n  }\n  /**\n   *  Return a new ``uint208`` type for %%v%%.\n   */\n  static uint208(v) {\n    return n(v, 208);\n  }\n  /**\n   *  Return a new ``uint216`` type for %%v%%.\n   */\n  static uint216(v) {\n    return n(v, 216);\n  }\n  /**\n   *  Return a new ``uint224`` type for %%v%%.\n   */\n  static uint224(v) {\n    return n(v, 224);\n  }\n  /**\n   *  Return a new ``uint232`` type for %%v%%.\n   */\n  static uint232(v) {\n    return n(v, 232);\n  }\n  /**\n   *  Return a new ``uint240`` type for %%v%%.\n   */\n  static uint240(v) {\n    return n(v, 240);\n  }\n  /**\n   *  Return a new ``uint248`` type for %%v%%.\n   */\n  static uint248(v) {\n    return n(v, 248);\n  }\n  /**\n   *  Return a new ``uint256`` type for %%v%%.\n   */\n  static uint256(v) {\n    return n(v, 256);\n  }\n  /**\n   *  Return a new ``uint256`` type for %%v%%.\n   */\n  static uint(v) {\n    return n(v, 256);\n  }\n  /**\n   *  Return a new ``int8`` type for %%v%%.\n   */\n  static int8(v) {\n    return n(v, -8);\n  }\n  /**\n   *  Return a new ``int16`` type for %%v%%.\n   */\n  static int16(v) {\n    return n(v, -16);\n  }\n  /**\n   *  Return a new ``int24`` type for %%v%%.\n   */\n  static int24(v) {\n    return n(v, -24);\n  }\n  /**\n   *  Return a new ``int32`` type for %%v%%.\n   */\n  static int32(v) {\n    return n(v, -32);\n  }\n  /**\n   *  Return a new ``int40`` type for %%v%%.\n   */\n  static int40(v) {\n    return n(v, -40);\n  }\n  /**\n   *  Return a new ``int48`` type for %%v%%.\n   */\n  static int48(v) {\n    return n(v, -48);\n  }\n  /**\n   *  Return a new ``int56`` type for %%v%%.\n   */\n  static int56(v) {\n    return n(v, -56);\n  }\n  /**\n   *  Return a new ``int64`` type for %%v%%.\n   */\n  static int64(v) {\n    return n(v, -64);\n  }\n  /**\n   *  Return a new ``int72`` type for %%v%%.\n   */\n  static int72(v) {\n    return n(v, -72);\n  }\n  /**\n   *  Return a new ``int80`` type for %%v%%.\n   */\n  static int80(v) {\n    return n(v, -80);\n  }\n  /**\n   *  Return a new ``int88`` type for %%v%%.\n   */\n  static int88(v) {\n    return n(v, -88);\n  }\n  /**\n   *  Return a new ``int96`` type for %%v%%.\n   */\n  static int96(v) {\n    return n(v, -96);\n  }\n  /**\n   *  Return a new ``int104`` type for %%v%%.\n   */\n  static int104(v) {\n    return n(v, -104);\n  }\n  /**\n   *  Return a new ``int112`` type for %%v%%.\n   */\n  static int112(v) {\n    return n(v, -112);\n  }\n  /**\n   *  Return a new ``int120`` type for %%v%%.\n   */\n  static int120(v) {\n    return n(v, -120);\n  }\n  /**\n   *  Return a new ``int128`` type for %%v%%.\n   */\n  static int128(v) {\n    return n(v, -128);\n  }\n  /**\n   *  Return a new ``int136`` type for %%v%%.\n   */\n  static int136(v) {\n    return n(v, -136);\n  }\n  /**\n   *  Return a new ``int144`` type for %%v%%.\n   */\n  static int144(v) {\n    return n(v, -144);\n  }\n  /**\n   *  Return a new ``int52`` type for %%v%%.\n   */\n  static int152(v) {\n    return n(v, -152);\n  }\n  /**\n   *  Return a new ``int160`` type for %%v%%.\n   */\n  static int160(v) {\n    return n(v, -160);\n  }\n  /**\n   *  Return a new ``int168`` type for %%v%%.\n   */\n  static int168(v) {\n    return n(v, -168);\n  }\n  /**\n   *  Return a new ``int176`` type for %%v%%.\n   */\n  static int176(v) {\n    return n(v, -176);\n  }\n  /**\n   *  Return a new ``int184`` type for %%v%%.\n   */\n  static int184(v) {\n    return n(v, -184);\n  }\n  /**\n   *  Return a new ``int92`` type for %%v%%.\n   */\n  static int192(v) {\n    return n(v, -192);\n  }\n  /**\n   *  Return a new ``int200`` type for %%v%%.\n   */\n  static int200(v) {\n    return n(v, -200);\n  }\n  /**\n   *  Return a new ``int208`` type for %%v%%.\n   */\n  static int208(v) {\n    return n(v, -208);\n  }\n  /**\n   *  Return a new ``int216`` type for %%v%%.\n   */\n  static int216(v) {\n    return n(v, -216);\n  }\n  /**\n   *  Return a new ``int224`` type for %%v%%.\n   */\n  static int224(v) {\n    return n(v, -224);\n  }\n  /**\n   *  Return a new ``int232`` type for %%v%%.\n   */\n  static int232(v) {\n    return n(v, -232);\n  }\n  /**\n   *  Return a new ``int240`` type for %%v%%.\n   */\n  static int240(v) {\n    return n(v, -240);\n  }\n  /**\n   *  Return a new ``int248`` type for %%v%%.\n   */\n  static int248(v) {\n    return n(v, -248);\n  }\n  /**\n   *  Return a new ``int256`` type for %%v%%.\n   */\n  static int256(v) {\n    return n(v, -256);\n  }\n  /**\n   *  Return a new ``int256`` type for %%v%%.\n   */\n  static int(v) {\n    return n(v, -256);\n  }\n  /**\n   *  Return a new ``bytes1`` type for %%v%%.\n   */\n  static bytes1(v) {\n    return b(v, 1);\n  }\n  /**\n   *  Return a new ``bytes2`` type for %%v%%.\n   */\n  static bytes2(v) {\n    return b(v, 2);\n  }\n  /**\n   *  Return a new ``bytes3`` type for %%v%%.\n   */\n  static bytes3(v) {\n    return b(v, 3);\n  }\n  /**\n   *  Return a new ``bytes4`` type for %%v%%.\n   */\n  static bytes4(v) {\n    return b(v, 4);\n  }\n  /**\n   *  Return a new ``bytes5`` type for %%v%%.\n   */\n  static bytes5(v) {\n    return b(v, 5);\n  }\n  /**\n   *  Return a new ``bytes6`` type for %%v%%.\n   */\n  static bytes6(v) {\n    return b(v, 6);\n  }\n  /**\n   *  Return a new ``bytes7`` type for %%v%%.\n   */\n  static bytes7(v) {\n    return b(v, 7);\n  }\n  /**\n   *  Return a new ``bytes8`` type for %%v%%.\n   */\n  static bytes8(v) {\n    return b(v, 8);\n  }\n  /**\n   *  Return a new ``bytes9`` type for %%v%%.\n   */\n  static bytes9(v) {\n    return b(v, 9);\n  }\n  /**\n   *  Return a new ``bytes10`` type for %%v%%.\n   */\n  static bytes10(v) {\n    return b(v, 10);\n  }\n  /**\n   *  Return a new ``bytes11`` type for %%v%%.\n   */\n  static bytes11(v) {\n    return b(v, 11);\n  }\n  /**\n   *  Return a new ``bytes12`` type for %%v%%.\n   */\n  static bytes12(v) {\n    return b(v, 12);\n  }\n  /**\n   *  Return a new ``bytes13`` type for %%v%%.\n   */\n  static bytes13(v) {\n    return b(v, 13);\n  }\n  /**\n   *  Return a new ``bytes14`` type for %%v%%.\n   */\n  static bytes14(v) {\n    return b(v, 14);\n  }\n  /**\n   *  Return a new ``bytes15`` type for %%v%%.\n   */\n  static bytes15(v) {\n    return b(v, 15);\n  }\n  /**\n   *  Return a new ``bytes16`` type for %%v%%.\n   */\n  static bytes16(v) {\n    return b(v, 16);\n  }\n  /**\n   *  Return a new ``bytes17`` type for %%v%%.\n   */\n  static bytes17(v) {\n    return b(v, 17);\n  }\n  /**\n   *  Return a new ``bytes18`` type for %%v%%.\n   */\n  static bytes18(v) {\n    return b(v, 18);\n  }\n  /**\n   *  Return a new ``bytes19`` type for %%v%%.\n   */\n  static bytes19(v) {\n    return b(v, 19);\n  }\n  /**\n   *  Return a new ``bytes20`` type for %%v%%.\n   */\n  static bytes20(v) {\n    return b(v, 20);\n  }\n  /**\n   *  Return a new ``bytes21`` type for %%v%%.\n   */\n  static bytes21(v) {\n    return b(v, 21);\n  }\n  /**\n   *  Return a new ``bytes22`` type for %%v%%.\n   */\n  static bytes22(v) {\n    return b(v, 22);\n  }\n  /**\n   *  Return a new ``bytes23`` type for %%v%%.\n   */\n  static bytes23(v) {\n    return b(v, 23);\n  }\n  /**\n   *  Return a new ``bytes24`` type for %%v%%.\n   */\n  static bytes24(v) {\n    return b(v, 24);\n  }\n  /**\n   *  Return a new ``bytes25`` type for %%v%%.\n   */\n  static bytes25(v) {\n    return b(v, 25);\n  }\n  /**\n   *  Return a new ``bytes26`` type for %%v%%.\n   */\n  static bytes26(v) {\n    return b(v, 26);\n  }\n  /**\n   *  Return a new ``bytes27`` type for %%v%%.\n   */\n  static bytes27(v) {\n    return b(v, 27);\n  }\n  /**\n   *  Return a new ``bytes28`` type for %%v%%.\n   */\n  static bytes28(v) {\n    return b(v, 28);\n  }\n  /**\n   *  Return a new ``bytes29`` type for %%v%%.\n   */\n  static bytes29(v) {\n    return b(v, 29);\n  }\n  /**\n   *  Return a new ``bytes30`` type for %%v%%.\n   */\n  static bytes30(v) {\n    return b(v, 30);\n  }\n  /**\n   *  Return a new ``bytes31`` type for %%v%%.\n   */\n  static bytes31(v) {\n    return b(v, 31);\n  }\n  /**\n   *  Return a new ``bytes32`` type for %%v%%.\n   */\n  static bytes32(v) {\n    return b(v, 32);\n  }\n  /**\n   *  Return a new ``address`` type for %%v%%.\n   */\n  static address(v) {\n    return new Typed(_gaurd, \"address\", v);\n  }\n  /**\n   *  Return a new ``bool`` type for %%v%%.\n   */\n  static bool(v) {\n    return new Typed(_gaurd, \"bool\", !!v);\n  }\n  /**\n   *  Return a new ``bytes`` type for %%v%%.\n   */\n  static bytes(v) {\n    return new Typed(_gaurd, \"bytes\", v);\n  }\n  /**\n   *  Return a new ``string`` type for %%v%%.\n   */\n  static string(v) {\n    return new Typed(_gaurd, \"string\", v);\n  }\n  /**\n   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n   */\n  static array(v, dynamic) {\n    throw new Error(\"not implemented yet\");\n    return new Typed(_gaurd, \"array\", v, dynamic);\n  }\n  /**\n   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n   */\n  static tuple(v, name) {\n    throw new Error(\"not implemented yet\");\n    return new Typed(_gaurd, \"tuple\", v, name);\n  }\n  /**\n   *  Return a new ``uint8`` type for %%v%%.\n   */\n  static overrides(v) {\n    return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n  }\n  /**\n   *  Returns true only if %%value%% is a [[Typed]] instance.\n   */\n  static isTyped(value) {\n    return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n  }\n  /**\n   *  If the value is a [[Typed]] instance, validates the underlying value\n   *  and returns it, otherwise returns value directly.\n   *\n   *  This is useful for functions that with to accept either a [[Typed]]\n   *  object or values.\n   */\n  static dereference(value, type) {\n    if (Typed.isTyped(value)) {\n      if (value.type !== type) {\n        throw new Error(\"invalid type: expecetd \".concat(type, \", got \").concat(value.type));\n      }\n      return value.value;\n    }\n    return value;\n  }\n}\n//# sourceMappingURL=typed.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}