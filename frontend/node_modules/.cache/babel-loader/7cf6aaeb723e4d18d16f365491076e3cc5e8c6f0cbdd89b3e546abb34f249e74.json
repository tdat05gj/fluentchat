{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/addresses.js\";\nimport { keccak256, sha256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, isBytesLike, isHexString, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { authorizationify } from \"./authorization.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst BLOB_SIZE = 4096 * 32;\nfunction getKzgLibrary(kzg) {\n  const blobToKzgCommitment = blob => {\n    if (\"computeBlobProof\" in kzg) {\n      // micro-ecc-signer; check for computeBlobProof since this API\n      // expects a string while the kzg-wasm below expects a Unit8Array\n      if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));\n      }\n    } else if (\"blobToKzgCommitment\" in kzg && typeof kzg.blobToKzgCommitment === \"function\") {\n      // kzg-wasm <0.5.0; blobToKzgCommitment(Uint8Array) => Uint8Array\n      return getBytes(kzg.blobToKzgCommitment(blob));\n    }\n    // kzg-wasm >= 0.5.0; blobToKZGCommitment(string) => string\n    if (\"blobToKZGCommitment\" in kzg && typeof kzg.blobToKZGCommitment === \"function\") {\n      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  const computeBlobKzgProof = (blob, commitment) => {\n    // micro-ecc-signer\n    if (\"computeBlobProof\" in kzg && typeof kzg.computeBlobProof === \"function\") {\n      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));\n    }\n    // kzg-wasm <0.5.0; computeBlobKzgProof(Uint8Array, Uint8Array) => Uint8Array\n    if (\"computeBlobKzgProof\" in kzg && typeof kzg.computeBlobKzgProof === \"function\") {\n      return kzg.computeBlobKzgProof(blob, commitment);\n    }\n    // kzg-wasm >= 0.5.0; computeBlobKZGProof(string, string) => string\n    if (\"computeBlobKZGProof\" in kzg && typeof kzg.computeBlobKZGProof === \"function\") {\n      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));\n    }\n    assertArgument(false, \"unsupported KZG library\", \"kzg\", kzg);\n  };\n  return {\n    blobToKzgCommitment,\n    computeBlobKzgProof\n  };\n}\nfunction getVersionedHash(version, hash) {\n  let versioned = version.toString(16);\n  while (versioned.length < 2) {\n    versioned = \"0\" + versioned;\n  }\n  versioned += sha256(hash).substring(4);\n  return \"0x\" + versioned;\n}\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleAuthorizationList(value, param) {\n  try {\n    if (!Array.isArray(value)) {\n      throw new Error(\"authorizationList: invalid array\");\n    }\n    const result = [];\n    for (let i = 0; i < value.length; i++) {\n      const auth = value[i];\n      if (!Array.isArray(auth)) {\n        throw new Error(\"authorization[\".concat(i, \"]: invalid array\"));\n      }\n      if (auth.length !== 6) {\n        throw new Error(\"authorization[\".concat(i, \"]: wrong length\"));\n      }\n      if (!auth[1]) {\n        throw new Error(\"authorization[\".concat(i, \"]: null address\"));\n      }\n      result.push({\n        address: handleAddress(auth[1]),\n        nonce: handleUint(auth[2], \"nonce\"),\n        chainId: handleUint(auth[0], \"chainId\"),\n        signature: Signature.from({\n          yParity: handleNumber(auth[3], \"yParity\"),\n          r: zeroPadValue(auth[4], 32),\n          s: zeroPadValue(auth[5], 32)\n        })\n      });\n    }\n    return result;\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  const value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  const value = getBigInt(_value, \"value\");\n  const result = toBeArray(value);\n  assertArgument(result.length <= 32, \"value too large\", \"tx.\".concat(name), value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction formatAuthorizationList(value) {\n  return value.map(a => {\n    return [formatNumber(a.chainId, \"chainId\"), a.address, formatNumber(a.nonce, \"nonce\"), formatNumber(a.signature.yParity, \"yParity\"), toBeArray(a.signature.r), toBeArray(a.signature.s)];\n  });\n}\nfunction formatHashes(value, param) {\n  assertArgument(Array.isArray(value), \"invalid \".concat(param), \"value\", value);\n  for (let i = 0; i < value.length; i++) {\n    assertArgument(isHexString(value[i], 32), \"invalid ${ param } hash\", \"value[\".concat(i, \"]\"), value[i]);\n  }\n  return value;\n}\nfunction _parseLegacy(data) {\n  const fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  const tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  const v = handleUint(fields[6], \"v\");\n  const r = handleUint(fields[7], \"r\");\n  const s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    let chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v\n    });\n    //tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  const fields = [formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data];\n  let chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    const legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  let v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  let yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  const r = zeroPadValue(fields[1], 32);\n  const s = zeroPadValue(fields[2], 32);\n  const signature = Signature.from({\n    r,\n    s,\n    yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  const tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  const tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  //tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\nfunction _parseEip4844(data) {\n  let fields = decodeRlp(getBytes(data).slice(1));\n  let typeName = \"3\";\n  let blobs = null;\n  // Parse the network format\n  if (fields.length === 4 && Array.isArray(fields[0])) {\n    typeName = \"3 (network format)\";\n    const fBlobs = fields[1],\n      fCommits = fields[2],\n      fProofs = fields[3];\n    assertArgument(Array.isArray(fBlobs), \"invalid network format: blobs not an array\", \"fields[1]\", fBlobs);\n    assertArgument(Array.isArray(fCommits), \"invalid network format: commitments not an array\", \"fields[2]\", fCommits);\n    assertArgument(Array.isArray(fProofs), \"invalid network format: proofs not an array\", \"fields[3]\", fProofs);\n    assertArgument(fBlobs.length === fCommits.length, \"invalid network format: blobs/commitments length mismatch\", \"fields\", fields);\n    assertArgument(fBlobs.length === fProofs.length, \"invalid network format: blobs/proofs length mismatch\", \"fields\", fields);\n    blobs = [];\n    for (let i = 0; i < fields[1].length; i++) {\n      blobs.push({\n        data: fBlobs[i],\n        commitment: fCommits[i],\n        proof: fProofs[i]\n      });\n    }\n    fields = fields[0];\n  }\n  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), \"invalid field count for transaction type: \".concat(typeName), \"data\", hexlify(data));\n  const tx = {\n    type: 3,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    maxFeePerBlobGas: handleUint(fields[9], \"maxFeePerBlobGas\"),\n    blobVersionedHashes: fields[10]\n  };\n  if (blobs) {\n    tx.blobs = blobs;\n  }\n  assertArgument(tx.to != null, \"invalid address for transaction type: \".concat(typeName), \"data\", data);\n  assertArgument(Array.isArray(tx.blobVersionedHashes), \"invalid blobVersionedHashes: must be an array\", \"data\", data);\n  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {\n    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), \"invalid blobVersionedHash at index \".concat(i, \": must be length 32\"), \"data\", data);\n  }\n  // Unsigned EIP-4844 Transaction\n  if (fields.length === 11) {\n    return tx;\n  }\n  // @TODO: Do we need to do this? This is only called internally\n  // and used to verify hashes; it might save time to not do this\n  //tx.hash = keccak256(concat([ \"0x03\", encodeRlp(fields) ]));\n  _parseEipSignature(tx, fields.slice(11));\n  return tx;\n}\nfunction _serializeEip4844(tx, sig, blobs) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || ZeroAddress, formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, \"maxFeePerBlobGas\"), formatHashes(tx.blobVersionedHashes || [], \"blobVersionedHashes\")];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    // We have blobs; return the network wrapped format\n    if (blobs) {\n      return concat([\"0x03\", encodeRlp([fields, blobs.map(b => b.data), blobs.map(b => b.commitment), blobs.map(b => b.proof)])]);\n    }\n  }\n  return concat([\"0x03\", encodeRlp(fields)]);\n}\nfunction _parseEip7702(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), \"invalid field count for transaction type: 4\", \"data\", hexlify(data));\n  const tx = {\n    type: 4,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: handleUint(fields[2], \"maxPriorityFeePerGas\"),\n    maxFeePerGas: handleUint(fields[3], \"maxFeePerGas\"),\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\"),\n    authorizationList: handleAuthorizationList(fields[9], \"authorizationList\")\n  };\n  // Unsigned EIP-7702 Transaction\n  if (fields.length === 10) {\n    return tx;\n  }\n  _parseEipSignature(tx, fields.slice(10));\n  return tx;\n}\nfunction _serializeEip7702(tx, sig) {\n  const fields = [formatNumber(tx.chainId, \"chainId\"), formatNumber(tx.nonce, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit, \"gasLimit\"), tx.to || \"0x\", formatNumber(tx.value, \"value\"), tx.data, formatAccessList(tx.accessList || []), formatAuthorizationList(tx.authorizationList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x04\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nvar _type = /*#__PURE__*/new WeakMap();\nvar _to = /*#__PURE__*/new WeakMap();\nvar _data = /*#__PURE__*/new WeakMap();\nvar _nonce = /*#__PURE__*/new WeakMap();\nvar _gasLimit = /*#__PURE__*/new WeakMap();\nvar _gasPrice = /*#__PURE__*/new WeakMap();\nvar _maxPriorityFeePerGas = /*#__PURE__*/new WeakMap();\nvar _maxFeePerGas = /*#__PURE__*/new WeakMap();\nvar _value2 = /*#__PURE__*/new WeakMap();\nvar _chainId = /*#__PURE__*/new WeakMap();\nvar _sig = /*#__PURE__*/new WeakMap();\nvar _accessList = /*#__PURE__*/new WeakMap();\nvar _maxFeePerBlobGas = /*#__PURE__*/new WeakMap();\nvar _blobVersionedHashes = /*#__PURE__*/new WeakMap();\nvar _kzg = /*#__PURE__*/new WeakMap();\nvar _blobs2 = /*#__PURE__*/new WeakMap();\nvar _auths = /*#__PURE__*/new WeakMap();\nvar _Transaction_brand = /*#__PURE__*/new WeakSet();\nexport class Transaction {\n  /**\n   *  The transaction type.\n   *\n   *  If null, the type will be automatically inferred based on\n   *  explicit properties.\n   */\n  get type() {\n    return _classPrivateFieldGet(_type, this);\n  }\n  set type(value) {\n    switch (value) {\n      case null:\n        _classPrivateFieldSet(_type, this, null);\n        break;\n      case 0:\n      case \"legacy\":\n        _classPrivateFieldSet(_type, this, 0);\n        break;\n      case 1:\n      case \"berlin\":\n      case \"eip-2930\":\n        _classPrivateFieldSet(_type, this, 1);\n        break;\n      case 2:\n      case \"london\":\n      case \"eip-1559\":\n        _classPrivateFieldSet(_type, this, 2);\n        break;\n      case 3:\n      case \"cancun\":\n      case \"eip-4844\":\n        _classPrivateFieldSet(_type, this, 3);\n        break;\n      case 4:\n      case \"pectra\":\n      case \"eip-7702\":\n        _classPrivateFieldSet(_type, this, 4);\n        break;\n      default:\n        assertArgument(false, \"unsupported transaction type\", \"type\", value);\n    }\n  }\n  /**\n   *  The name of the transaction type.\n   */\n  get typeName() {\n    switch (this.type) {\n      case 0:\n        return \"legacy\";\n      case 1:\n        return \"eip-2930\";\n      case 2:\n        return \"eip-1559\";\n      case 3:\n        return \"eip-4844\";\n      case 4:\n        return \"eip-7702\";\n    }\n    return null;\n  }\n  /**\n   *  The ``to`` address for the transaction or ``null`` if the\n   *  transaction is an ``init`` transaction.\n   */\n  get to() {\n    const value = _classPrivateFieldGet(_to, this);\n    if (value == null && this.type === 3) {\n      return ZeroAddress;\n    }\n    return value;\n  }\n  set to(value) {\n    _classPrivateFieldSet(_to, this, value == null ? null : getAddress(value));\n  }\n  /**\n   *  The transaction nonce.\n   */\n  get nonce() {\n    return _classPrivateFieldGet(_nonce, this);\n  }\n  set nonce(value) {\n    _classPrivateFieldSet(_nonce, this, getNumber(value, \"value\"));\n  }\n  /**\n   *  The gas limit.\n   */\n  get gasLimit() {\n    return _classPrivateFieldGet(_gasLimit, this);\n  }\n  set gasLimit(value) {\n    _classPrivateFieldSet(_gasLimit, this, getBigInt(value));\n  }\n  /**\n   *  The gas price.\n   *\n   *  On legacy networks this defines the fee that will be paid. On\n   *  EIP-1559 networks, this should be ``null``.\n   */\n  get gasPrice() {\n    const value = _classPrivateFieldGet(_gasPrice, this);\n    if (value == null && (this.type === 0 || this.type === 1)) {\n      return BN_0;\n    }\n    return value;\n  }\n  set gasPrice(value) {\n    _classPrivateFieldSet(_gasPrice, this, value == null ? null : getBigInt(value, \"gasPrice\"));\n  }\n  /**\n   *  The maximum priority fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxPriorityFeePerGas() {\n    const value = _classPrivateFieldGet(_maxPriorityFeePerGas, this);\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxPriorityFeePerGas(value) {\n    _classPrivateFieldSet(_maxPriorityFeePerGas, this, value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\"));\n  }\n  /**\n   *  The maximum total fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxFeePerGas() {\n    const value = _classPrivateFieldGet(_maxFeePerGas, this);\n    if (value == null) {\n      if (this.type === 2 || this.type === 3) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxFeePerGas(value) {\n    _classPrivateFieldSet(_maxFeePerGas, this, value == null ? null : getBigInt(value, \"maxFeePerGas\"));\n  }\n  /**\n   *  The transaction data. For ``init`` transactions this is the\n   *  deployment code.\n   */\n  get data() {\n    return _classPrivateFieldGet(_data, this);\n  }\n  set data(value) {\n    _classPrivateFieldSet(_data, this, hexlify(value));\n  }\n  /**\n   *  The amount of ether (in wei) to send in this transactions.\n   */\n  get value() {\n    return _classPrivateFieldGet(_value2, this);\n  }\n  set value(value) {\n    _classPrivateFieldSet(_value2, this, getBigInt(value, \"value\"));\n  }\n  /**\n   *  The chain ID this transaction is valid on.\n   */\n  get chainId() {\n    return _classPrivateFieldGet(_chainId, this);\n  }\n  set chainId(value) {\n    _classPrivateFieldSet(_chainId, this, getBigInt(value));\n  }\n  /**\n   *  If signed, the signature for this transaction.\n   */\n  get signature() {\n    return _classPrivateFieldGet(_sig, this) || null;\n  }\n  set signature(value) {\n    _classPrivateFieldSet(_sig, this, value == null ? null : Signature.from(value));\n  }\n  /**\n   *  The access list.\n   *\n   *  An access list permits discounted (but pre-paid) access to\n   *  bytecode and state variable access within contract execution.\n   */\n  get accessList() {\n    const value = _classPrivateFieldGet(_accessList, this) || null;\n    if (value == null) {\n      if (this.type === 1 || this.type === 2 || this.type === 3) {\n        // @TODO: in v7, this should assign the value or become\n        // a live object itself, otherwise mutation is inconsistent\n        return [];\n      }\n      return null;\n    }\n    return value;\n  }\n  set accessList(value) {\n    _classPrivateFieldSet(_accessList, this, value == null ? null : accessListify(value));\n  }\n  get authorizationList() {\n    const value = _classPrivateFieldGet(_auths, this) || null;\n    if (value == null) {\n      if (this.type === 4) {\n        // @TODO: in v7, this should become a live object itself,\n        // otherwise mutation is inconsistent\n        return [];\n      }\n    }\n    return value;\n  }\n  set authorizationList(auths) {\n    _classPrivateFieldSet(_auths, this, auths == null ? null : auths.map(a => authorizationify(a)));\n  }\n  /**\n   *  The max fee per blob gas for Cancun transactions.\n   */\n  get maxFeePerBlobGas() {\n    const value = _classPrivateFieldGet(_maxFeePerBlobGas, this);\n    if (value == null && this.type === 3) {\n      return BN_0;\n    }\n    return value;\n  }\n  set maxFeePerBlobGas(value) {\n    _classPrivateFieldSet(_maxFeePerBlobGas, this, value == null ? null : getBigInt(value, \"maxFeePerBlobGas\"));\n  }\n  /**\n   *  The BLOb versioned hashes for Cancun transactions.\n   */\n  get blobVersionedHashes() {\n    // @TODO: Mutation is inconsistent; if unset, the returned value\n    // cannot mutate the object, if set it can\n    let value = _classPrivateFieldGet(_blobVersionedHashes, this);\n    if (value == null && this.type === 3) {\n      return [];\n    }\n    return value;\n  }\n  set blobVersionedHashes(value) {\n    if (value != null) {\n      assertArgument(Array.isArray(value), \"blobVersionedHashes must be an Array\", \"value\", value);\n      value = value.slice();\n      for (let i = 0; i < value.length; i++) {\n        assertArgument(isHexString(value[i], 32), \"invalid blobVersionedHash\", \"value[\".concat(i, \"]\"), value[i]);\n      }\n    }\n    _classPrivateFieldSet(_blobVersionedHashes, this, value);\n  }\n  /**\n   *  The BLObs for the Transaction, if any.\n   *\n   *  If ``blobs`` is non-``null``, then the [[seriailized]]\n   *  will return the network formatted sidecar, otherwise it\n   *  will return the standard [[link-eip-2718]] payload. The\n   *  [[unsignedSerialized]] is unaffected regardless.\n   *\n   *  When setting ``blobs``, either fully valid [[Blob]] objects\n   *  may be specified (i.e. correctly padded, with correct\n   *  committments and proofs) or a raw [[BytesLike]] may\n   *  be provided.\n   *\n   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**\n   *  be already set. The blob will be correctly padded and the\n   *  [[KzgLibrary]] will be used to compute the committment and\n   *  proof for the blob.\n   *\n   *  A BLOb is a sequence of field elements, each of which must\n   *  be within the BLS field modulo, so some additional processing\n   *  may be required to encode arbitrary data to ensure each 32 byte\n   *  field is within the valid range.\n   *\n   *  Setting this automatically populates [[blobVersionedHashes]],\n   *  overwriting any existing values. Setting this to ``null``\n   *  does **not** remove the [[blobVersionedHashes]], leaving them\n   *  present.\n   */\n  get blobs() {\n    if (_classPrivateFieldGet(_blobs2, this) == null) {\n      return null;\n    }\n    return _classPrivateFieldGet(_blobs2, this).map(b => Object.assign({}, b));\n  }\n  set blobs(_blobs) {\n    if (_blobs == null) {\n      _classPrivateFieldSet(_blobs2, this, null);\n      return;\n    }\n    const blobs = [];\n    const versionedHashes = [];\n    for (let i = 0; i < _blobs.length; i++) {\n      const blob = _blobs[i];\n      if (isBytesLike(blob)) {\n        assert(_classPrivateFieldGet(_kzg, this), \"adding a raw blob requires a KZG library\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"set blobs()\"\n        });\n        let data = getBytes(blob);\n        assertArgument(data.length <= BLOB_SIZE, \"blob is too large\", \"blobs[\".concat(i, \"]\"), blob);\n        // Pad blob if necessary\n        if (data.length !== BLOB_SIZE) {\n          const padded = new Uint8Array(BLOB_SIZE);\n          padded.set(data);\n          data = padded;\n        }\n        const commit = _classPrivateFieldGet(_kzg, this).blobToKzgCommitment(data);\n        const proof = hexlify(_classPrivateFieldGet(_kzg, this).computeBlobKzgProof(data, commit));\n        blobs.push({\n          data: hexlify(data),\n          commitment: hexlify(commit),\n          proof\n        });\n        versionedHashes.push(getVersionedHash(1, commit));\n      } else {\n        const commit = hexlify(blob.commitment);\n        blobs.push({\n          data: hexlify(blob.data),\n          commitment: commit,\n          proof: hexlify(blob.proof)\n        });\n        versionedHashes.push(getVersionedHash(1, commit));\n      }\n    }\n    _classPrivateFieldSet(_blobs2, this, blobs);\n    _classPrivateFieldSet(_blobVersionedHashes, this, versionedHashes);\n  }\n  get kzg() {\n    return _classPrivateFieldGet(_kzg, this);\n  }\n  set kzg(kzg) {\n    if (kzg == null) {\n      _classPrivateFieldSet(_kzg, this, null);\n    } else {\n      _classPrivateFieldSet(_kzg, this, getKzgLibrary(kzg));\n    }\n  }\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  constructor() {\n    _classPrivateMethodInitSpec(this, _Transaction_brand);\n    _classPrivateFieldInitSpec(this, _type, void 0);\n    _classPrivateFieldInitSpec(this, _to, void 0);\n    _classPrivateFieldInitSpec(this, _data, void 0);\n    _classPrivateFieldInitSpec(this, _nonce, void 0);\n    _classPrivateFieldInitSpec(this, _gasLimit, void 0);\n    _classPrivateFieldInitSpec(this, _gasPrice, void 0);\n    _classPrivateFieldInitSpec(this, _maxPriorityFeePerGas, void 0);\n    _classPrivateFieldInitSpec(this, _maxFeePerGas, void 0);\n    _classPrivateFieldInitSpec(this, _value2, void 0);\n    _classPrivateFieldInitSpec(this, _chainId, void 0);\n    _classPrivateFieldInitSpec(this, _sig, void 0);\n    _classPrivateFieldInitSpec(this, _accessList, void 0);\n    _classPrivateFieldInitSpec(this, _maxFeePerBlobGas, void 0);\n    _classPrivateFieldInitSpec(this, _blobVersionedHashes, void 0);\n    _classPrivateFieldInitSpec(this, _kzg, void 0);\n    _classPrivateFieldInitSpec(this, _blobs2, void 0);\n    _classPrivateFieldInitSpec(this, _auths, void 0);\n    _classPrivateFieldSet(_type, this, null);\n    _classPrivateFieldSet(_to, this, null);\n    _classPrivateFieldSet(_nonce, this, 0);\n    _classPrivateFieldSet(_gasLimit, this, BN_0);\n    _classPrivateFieldSet(_gasPrice, this, null);\n    _classPrivateFieldSet(_maxPriorityFeePerGas, this, null);\n    _classPrivateFieldSet(_maxFeePerGas, this, null);\n    _classPrivateFieldSet(_data, this, \"0x\");\n    _classPrivateFieldSet(_value2, this, BN_0);\n    _classPrivateFieldSet(_chainId, this, BN_0);\n    _classPrivateFieldSet(_sig, this, null);\n    _classPrivateFieldSet(_accessList, this, null);\n    _classPrivateFieldSet(_maxFeePerBlobGas, this, null);\n    _classPrivateFieldSet(_blobVersionedHashes, this, null);\n    _classPrivateFieldSet(_kzg, this, null);\n    _classPrivateFieldSet(_blobs2, this, null);\n    _classPrivateFieldSet(_auths, this, null);\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  get hash() {\n    if (this.signature == null) {\n      return null;\n    }\n    return keccak256(_assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, false));\n  }\n  /**\n   *  The pre-image hash of this transaction.\n   *\n   *  This is the digest that a [[Signer]] must sign to authorize\n   *  this transaction.\n   */\n  get unsignedHash() {\n    return keccak256(this.unsignedSerialized);\n  }\n  /**\n   *  The sending address, if signed. Otherwise, ``null``.\n   */\n  get from() {\n    if (this.signature == null) {\n      return null;\n    }\n    return recoverAddress(this.unsignedHash, this.signature);\n  }\n  /**\n   *  The public key of the sender, if signed. Otherwise, ``null``.\n   */\n  get fromPublicKey() {\n    if (this.signature == null) {\n      return null;\n    }\n    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n  }\n  /**\n   *  Returns true if signed.\n   *\n   *  This provides a Type Guard that properties requiring a signed\n   *  transaction are non-null.\n   */\n  isSigned() {\n    return this.signature != null;\n  }\n  /**\n   *  The serialized transaction.\n   *\n   *  This throws if the transaction is unsigned. For the pre-image,\n   *  use [[unsignedSerialized]].\n   */\n  get serialized() {\n    return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, true);\n  }\n  /**\n   *  The transaction pre-image.\n   *\n   *  The hash of this is the digest which needs to be signed to\n   *  authorize this transaction.\n   */\n  get unsignedSerialized() {\n    return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, false, false);\n  }\n  /**\n   *  Return the most \"likely\" type; currently the highest\n   *  supported transaction type.\n   */\n  inferType() {\n    const types = this.inferTypes();\n    // Prefer London (EIP-1559) over Cancun (BLOb)\n    if (types.indexOf(2) >= 0) {\n      return 2;\n    }\n    // Return the highest inferred type\n    return types.pop();\n  }\n  /**\n   *  Validates the explicit properties and returns a list of compatible\n   *  transaction types.\n   */\n  inferTypes() {\n    // Checks that there are no conflicting properties set\n    const hasGasPrice = this.gasPrice != null;\n    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n    const hasAccessList = this.accessList != null;\n    const hasBlob = _classPrivateFieldGet(_maxFeePerBlobGas, this) != null || _classPrivateFieldGet(_blobVersionedHashes, this);\n    //if (hasGasPrice && hasFee) {\n    //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n    //}\n    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n        value: this\n      });\n    }\n    //if (this.type === 2 && hasGasPrice) {\n    //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n    //}\n    assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n      value: this\n    });\n    assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n      value: this\n    });\n    const types = [];\n    // Explicit type\n    if (this.type != null) {\n      types.push(this.type);\n    } else {\n      if (this.authorizationList && this.authorizationList.length) {\n        types.push(4);\n      } else if (hasFee) {\n        types.push(2);\n      } else if (hasGasPrice) {\n        types.push(1);\n        if (!hasAccessList) {\n          types.push(0);\n        }\n      } else if (hasAccessList) {\n        types.push(1);\n        types.push(2);\n      } else if (hasBlob && this.to) {\n        types.push(3);\n      } else {\n        types.push(0);\n        types.push(1);\n        types.push(2);\n        types.push(3);\n      }\n    }\n    types.sort();\n    return types;\n  }\n  /**\n   *  Returns true if this transaction is a legacy transaction (i.e.\n   *  ``type === 0``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if this transaction is berlin hardform transaction (i.e.\n   *  ``type === 1``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if this transaction is london hardform transaction (i.e.\n   *  ``type === 2``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Returns true if this transaction is an [[link-eip-4844]] BLOB\n   *  transaction.\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isCancun() {\n    return this.type === 3;\n  }\n  /**\n   *  Create a copy of this transaciton.\n   */\n  clone() {\n    return Transaction.from(this);\n  }\n  /**\n   *  Return a JSON-friendly object.\n   */\n  toJSON() {\n    const s = v => {\n      if (v == null) {\n        return null;\n      }\n      return v.toString();\n    };\n    return {\n      type: this.type,\n      to: this.to,\n      //            from: this.from,\n      data: this.data,\n      nonce: this.nonce,\n      gasLimit: s(this.gasLimit),\n      gasPrice: s(this.gasPrice),\n      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n      maxFeePerGas: s(this.maxFeePerGas),\n      value: s(this.value),\n      chainId: s(this.chainId),\n      sig: this.signature ? this.signature.toJSON() : null,\n      accessList: this.accessList\n    };\n  }\n  /**\n   *  Create a **Transaction** from a serialized transaction or a\n   *  Transaction-like object.\n   */\n  static from(tx) {\n    if (tx == null) {\n      return new Transaction();\n    }\n    if (typeof tx === \"string\") {\n      const payload = getBytes(tx);\n      if (payload[0] >= 0x7f) {\n        // @TODO: > vs >= ??\n        return Transaction.from(_parseLegacy(payload));\n      }\n      switch (payload[0]) {\n        case 1:\n          return Transaction.from(_parseEip2930(payload));\n        case 2:\n          return Transaction.from(_parseEip1559(payload));\n        case 3:\n          return Transaction.from(_parseEip4844(payload));\n        case 4:\n          return Transaction.from(_parseEip7702(payload));\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"from\"\n      });\n    }\n    const result = new Transaction();\n    if (tx.type != null) {\n      result.type = tx.type;\n    }\n    if (tx.to != null) {\n      result.to = tx.to;\n    }\n    if (tx.nonce != null) {\n      result.nonce = tx.nonce;\n    }\n    if (tx.gasLimit != null) {\n      result.gasLimit = tx.gasLimit;\n    }\n    if (tx.gasPrice != null) {\n      result.gasPrice = tx.gasPrice;\n    }\n    if (tx.maxPriorityFeePerGas != null) {\n      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n    }\n    if (tx.maxFeePerGas != null) {\n      result.maxFeePerGas = tx.maxFeePerGas;\n    }\n    if (tx.maxFeePerBlobGas != null) {\n      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;\n    }\n    if (tx.data != null) {\n      result.data = tx.data;\n    }\n    if (tx.value != null) {\n      result.value = tx.value;\n    }\n    if (tx.chainId != null) {\n      result.chainId = tx.chainId;\n    }\n    if (tx.signature != null) {\n      result.signature = Signature.from(tx.signature);\n    }\n    if (tx.accessList != null) {\n      result.accessList = tx.accessList;\n    }\n    if (tx.authorizationList != null) {\n      result.authorizationList = tx.authorizationList;\n    }\n    // This will get overwritten by blobs, if present\n    if (tx.blobVersionedHashes != null) {\n      result.blobVersionedHashes = tx.blobVersionedHashes;\n    }\n    // Make sure we assign the kzg before assigning blobs, which\n    // require the library in the event raw blob data is provided.\n    if (tx.kzg != null) {\n      result.kzg = tx.kzg;\n    }\n    if (tx.blobs != null) {\n      result.blobs = tx.blobs;\n    }\n    if (tx.hash != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.hash'\", \"tx\", tx);\n      assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n    }\n    if (tx.from != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define '.from'\", \"tx\", tx);\n      assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n    }\n    return result;\n  }\n}\n//# sourceMappingURL=transaction.js.map\nfunction _getSerialized(signed, sidecar) {\n  assert(!signed || this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n    operation: \".serialized\"\n  });\n  const sig = signed ? this.signature : null;\n  switch (this.inferType()) {\n    case 0:\n      return _serializeLegacy(this, sig);\n    case 1:\n      return _serializeEip2930(this, sig);\n    case 2:\n      return _serializeEip1559(this, sig);\n    case 3:\n      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);\n    case 4:\n      return _serializeEip7702(this, sig);\n  }\n  assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n    operation: \".serialized\"\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}