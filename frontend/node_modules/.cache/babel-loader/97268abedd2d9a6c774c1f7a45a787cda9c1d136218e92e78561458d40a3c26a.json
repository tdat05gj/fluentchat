{"ast":null,"code":"/**\n *  @_ignore\n */\nimport { getAddress, getCreateAddress } from \"../address/index.js\";\nimport { Signature } from \"../crypto/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport { getBigInt, getNumber, hexlify, isHexString, zeroPadValue, assert, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nexport function allowNull(format, nullValue) {\n  return function (value) {\n    if (value == null) {\n      return nullValue;\n    }\n    return format(value);\n  };\n}\nexport function arrayOf(format, allowNull) {\n  return array => {\n    if (allowNull && array == null) {\n      return null;\n    }\n    if (!Array.isArray(array)) {\n      throw new Error(\"not an array\");\n    }\n    return array.map(i => format(i));\n  };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nexport function object(format, altNames) {\n  return value => {\n    const result = {};\n    for (const key in format) {\n      let srcKey = key;\n      if (altNames && key in altNames && !(srcKey in value)) {\n        for (const altKey of altNames[key]) {\n          if (altKey in value) {\n            srcKey = altKey;\n            break;\n          }\n        }\n      }\n      try {\n        const nv = format[key](value[srcKey]);\n        if (nv !== undefined) {\n          result[key] = nv;\n        }\n      } catch (error) {\n        const message = error instanceof Error ? error.message : \"not-an-error\";\n        assert(false, \"invalid value for value.\".concat(key, \" (\").concat(message, \")\"), \"BAD_DATA\", {\n          value\n        });\n      }\n    }\n    return result;\n  };\n}\nexport function formatBoolean(value) {\n  switch (value) {\n    case true:\n    case \"true\":\n      return true;\n    case false:\n    case \"false\":\n      return false;\n  }\n  assertArgument(false, \"invalid boolean; \".concat(JSON.stringify(value)), \"value\", value);\n}\nexport function formatData(value) {\n  assertArgument(isHexString(value, true), \"invalid data\", \"value\", value);\n  return value;\n}\nexport function formatHash(value) {\n  assertArgument(isHexString(value, 32), \"invalid hash\", \"value\", value);\n  return value;\n}\nexport function formatUint256(value) {\n  if (!isHexString(value)) {\n    throw new Error(\"invalid uint256\");\n  }\n  return zeroPadValue(value, 32);\n}\nconst _formatLog = object({\n  address: getAddress,\n  blockHash: formatHash,\n  blockNumber: getNumber,\n  data: formatData,\n  index: getNumber,\n  removed: allowNull(formatBoolean, false),\n  topics: arrayOf(formatHash),\n  transactionHash: formatHash,\n  transactionIndex: getNumber\n}, {\n  index: [\"logIndex\"]\n});\nexport function formatLog(value) {\n  return _formatLog(value);\n}\nconst _formatBlock = object({\n  hash: allowNull(formatHash),\n  parentHash: formatHash,\n  parentBeaconBlockRoot: allowNull(formatHash, null),\n  number: getNumber,\n  timestamp: getNumber,\n  nonce: allowNull(formatData),\n  difficulty: getBigInt,\n  gasLimit: getBigInt,\n  gasUsed: getBigInt,\n  stateRoot: allowNull(formatHash, null),\n  receiptsRoot: allowNull(formatHash, null),\n  blobGasUsed: allowNull(getBigInt, null),\n  excessBlobGas: allowNull(getBigInt, null),\n  miner: allowNull(getAddress),\n  prevRandao: allowNull(formatHash, null),\n  extraData: formatData,\n  baseFeePerGas: allowNull(getBigInt)\n}, {\n  prevRandao: [\"mixHash\"]\n});\nexport function formatBlock(value) {\n  const result = _formatBlock(value);\n  result.transactions = value.transactions.map(tx => {\n    if (typeof tx === \"string\") {\n      return tx;\n    }\n    return formatTransactionResponse(tx);\n  });\n  return result;\n}\nconst _formatReceiptLog = object({\n  transactionIndex: getNumber,\n  blockNumber: getNumber,\n  transactionHash: formatHash,\n  address: getAddress,\n  topics: arrayOf(formatHash),\n  data: formatData,\n  index: getNumber,\n  blockHash: formatHash\n}, {\n  index: [\"logIndex\"]\n});\nexport function formatReceiptLog(value) {\n  return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n  to: allowNull(getAddress, null),\n  from: allowNull(getAddress, null),\n  contractAddress: allowNull(getAddress, null),\n  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n  index: getNumber,\n  root: allowNull(hexlify),\n  gasUsed: getBigInt,\n  blobGasUsed: allowNull(getBigInt, null),\n  logsBloom: allowNull(formatData),\n  blockHash: formatHash,\n  hash: formatHash,\n  logs: arrayOf(formatReceiptLog),\n  blockNumber: getNumber,\n  //confirmations: allowNull(getNumber, null),\n  cumulativeGasUsed: getBigInt,\n  effectiveGasPrice: allowNull(getBigInt),\n  blobGasPrice: allowNull(getBigInt, null),\n  status: allowNull(getNumber),\n  type: allowNull(getNumber, 0)\n}, {\n  effectiveGasPrice: [\"gasPrice\"],\n  hash: [\"transactionHash\"],\n  index: [\"transactionIndex\"]\n});\nexport function formatTransactionReceipt(value) {\n  return _formatTransactionReceipt(value);\n}\nexport function formatTransactionResponse(value) {\n  // Some clients (TestRPC) do strange things like return 0x0 for the\n  // 0 address; correct this to be a real address\n  if (value.to && getBigInt(value.to) === BN_0) {\n    value.to = \"0x0000000000000000000000000000000000000000\";\n  }\n  const result = object({\n    hash: formatHash,\n    // Some nodes do not return this, usually test nodes (like Ganache)\n    index: allowNull(getNumber, undefined),\n    type: value => {\n      if (value === \"0x\" || value == null) {\n        return 0;\n      }\n      return getNumber(value);\n    },\n    accessList: allowNull(accessListify, null),\n    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n    authorizationList: allowNull(arrayOf(v => {\n      let sig;\n      if (v.signature) {\n        sig = v.signature;\n      } else {\n        let yParity = v.yParity;\n        if (yParity === \"0x1b\") {\n          yParity = 0;\n        } else if (yParity === \"0x1c\") {\n          yParity = 1;\n        }\n        sig = Object.assign({}, v, {\n          yParity\n        });\n      }\n      return {\n        address: getAddress(v.address),\n        chainId: getBigInt(v.chainId),\n        nonce: getBigInt(v.nonce),\n        signature: Signature.from(sig)\n      };\n    }, false), null),\n    blockHash: allowNull(formatHash, null),\n    blockNumber: allowNull(getNumber, null),\n    transactionIndex: allowNull(getNumber, null),\n    from: getAddress,\n    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n    gasPrice: allowNull(getBigInt),\n    maxPriorityFeePerGas: allowNull(getBigInt),\n    maxFeePerGas: allowNull(getBigInt),\n    maxFeePerBlobGas: allowNull(getBigInt, null),\n    gasLimit: getBigInt,\n    to: allowNull(getAddress, null),\n    value: getBigInt,\n    nonce: getNumber,\n    data: formatData,\n    creates: allowNull(getAddress, null),\n    chainId: allowNull(getBigInt, null)\n  }, {\n    data: [\"input\"],\n    gasLimit: [\"gas\"],\n    index: [\"transactionIndex\"]\n  })(value);\n  // If to and creates are empty, populate the creates from the value\n  if (result.to == null && result.creates == null) {\n    result.creates = getCreateAddress(result);\n  }\n  // @TODO: Check fee data\n  // Add an access list to supported transaction types\n  if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n    result.accessList = [];\n  }\n  // Compute the signature\n  if (value.signature) {\n    result.signature = Signature.from(value.signature);\n  } else {\n    result.signature = Signature.from(value);\n  }\n  // Some backends omit ChainId on legacy transactions, but we can compute it\n  if (result.chainId == null) {\n    const chainId = result.signature.legacyChainId;\n    if (chainId != null) {\n      result.chainId = chainId;\n    }\n  }\n  // @TODO: check chainID\n  /*\n  if (value.chainId != null) {\n      let chainId = value.chainId;\n       if (isHexString(chainId)) {\n          chainId = BigNumber.from(chainId).toNumber();\n      }\n       result.chainId = chainId;\n   } else {\n      let chainId = value.networkId;\n       // geth-etc returns chainId\n      if (chainId == null && result.v == null) {\n          chainId = value.chainId;\n      }\n       if (isHexString(chainId)) {\n          chainId = BigNumber.from(chainId).toNumber();\n      }\n       if (typeof(chainId) !== \"number\" && result.v != null) {\n          chainId = (result.v - 35) / 2;\n          if (chainId < 0) { chainId = 0; }\n          chainId = parseInt(chainId);\n      }\n       if (typeof(chainId) !== \"number\") { chainId = 0; }\n       result.chainId = chainId;\n  }\n  */\n  // 0x0000... should actually be null\n  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {\n    result.blockHash = null;\n  }\n  return result;\n}\n//# sourceMappingURL=format.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}