{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/ } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n  return resultNames.get(result);\n}\nfunction setNames(result, names) {\n  resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n  const wrapped = new Error(\"deferred error during ABI decoding triggered accessing \".concat(name));\n  wrapped.error = error;\n  throw wrapped;\n}\nfunction toObject(names, items, deep) {\n  if (names.indexOf(null) >= 0) {\n    return items.map((item, index) => {\n      if (item instanceof Result) {\n        return toObject(getNames(item), item, deep);\n      }\n      return item;\n    });\n  }\n  return names.reduce((accum, name, index) => {\n    let item = items.getValue(name);\n    if (!(name in accum)) {\n      if (deep && item instanceof Result) {\n        item = toObject(getNames(item), item, deep);\n      }\n      accum[name] = item;\n    }\n    return accum;\n  }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nvar _names2 = /*#__PURE__*/new WeakMap();\nexport class Result extends Array {\n  /**\n   *  @private\n   */\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    _classPrivateFieldInitSpec(this, _names2, void 0);\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    setNames(this, Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    // Dummy operations to prevent TypeScript from complaining\n    _classPrivateFieldSet(_names2, this, []);\n    if (_classPrivateFieldGet(_names2, this) == null) {\n      void _classPrivateFieldGet(_names2, this);\n    }\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    const proxy = new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = getNumber(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(\"index \".concat(index), item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function () {\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n    setNames(proxy, getNames(this));\n    return proxy;\n  }\n  /**\n   *  Returns the Result as a normal Array. If %%deep%%, any children\n   *  which are Result objects are also converted to a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray(deep) {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(\"index \".concat(index), item);\n      }\n      if (deep && item instanceof Result) {\n        item = item.toArray(deep);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair. If\n   *  %%deep%%, any children which are Result objects are also\n   *  converted to an Object.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject(deep) {\n    const names = getNames(this);\n    return names.reduce((accum, name, index) => {\n      assert(name != null, \"value at index \".concat(index, \" unnamed\"), \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      return toObject(names, this, deep);\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(_names[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(\"index \".concat(i), item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(_names[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  map(callback, thisArg) {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(\"index \".concat(i), item);\n      }\n      result.push(callback.call(thisArg, item, i, this));\n    }\n    return result;\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = getNames(this).indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(\"property \".concat(JSON.stringify(name)), value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nfunction getValue(value) {\n  let bytes = toBeArray(value);\n  assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== WordSize) {\n    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    _defineProperty(this, \"name\", void 0);\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    _defineProperty(this, \"type\", void 0);\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    _defineProperty(this, \"localName\", void 0);\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    _defineProperty(this, \"dynamic\", void 0);\n    defineProperties(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    assertArgument(false, message, this.localName, value);\n  }\n}\n/**\n *  @_ignore\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _Writer_brand = /*#__PURE__*/new WeakSet();\nexport class Writer {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _Writer_brand);\n    // An array of WordSize lengthed objects to concatenation\n    _classPrivateFieldInitSpec(this, _data, void 0);\n    _classPrivateFieldInitSpec(this, _dataLength, void 0);\n    _classPrivateFieldSet(_data, this, []);\n    _classPrivateFieldSet(_dataLength, this, 0);\n  }\n  get data() {\n    return concat(_classPrivateFieldGet(_data, this));\n  }\n  get length() {\n    return _classPrivateFieldGet(_dataLength, this);\n  }\n  appendWriter(writer) {\n    return _assertClassBrand(_Writer_brand, this, _writeData).call(this, getBytesCopy(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = getBytesCopy(value);\n    const paddingOffset = bytes.length % WordSize;\n    if (paddingOffset) {\n      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n    }\n    return _assertClassBrand(_Writer_brand, this, _writeData).call(this, bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return _assertClassBrand(_Writer_brand, this, _writeData).call(this, getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = _classPrivateFieldGet(_data, this).length;\n    _classPrivateFieldGet(_data, this).push(Padding);\n    _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_dataLength, this) + WordSize);\n    return value => {\n      _classPrivateFieldGet(_data, this)[offset] = getValue(value);\n    };\n  }\n}\n/**\n *  @_ignore\n */\nfunction _writeData(data) {\n  _classPrivateFieldGet(_data, this).push(data);\n  _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_dataLength, this) + data.length);\n  return data.length;\n}\nvar _data2 = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _bytesRead = /*#__PURE__*/new WeakMap();\nvar _parent = /*#__PURE__*/new WeakMap();\nvar _maxInflation = /*#__PURE__*/new WeakMap();\nvar _Reader_brand = /*#__PURE__*/new WeakSet();\nexport class Reader {\n  constructor(data, allowLoose, maxInflation) {\n    _classPrivateMethodInitSpec(this, _Reader_brand);\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    _defineProperty(this, \"allowLoose\", void 0);\n    _classPrivateFieldInitSpec(this, _data2, void 0);\n    _classPrivateFieldInitSpec(this, _offset, void 0);\n    _classPrivateFieldInitSpec(this, _bytesRead, void 0);\n    _classPrivateFieldInitSpec(this, _parent, void 0);\n    _classPrivateFieldInitSpec(this, _maxInflation, void 0);\n    defineProperties(this, {\n      allowLoose: !!allowLoose\n    });\n    _classPrivateFieldSet(_data2, this, getBytesCopy(data));\n    _classPrivateFieldSet(_bytesRead, this, 0);\n    _classPrivateFieldSet(_parent, this, null);\n    _classPrivateFieldSet(_maxInflation, this, maxInflation != null ? maxInflation : 1024);\n    _classPrivateFieldSet(_offset, this, 0);\n  }\n  get data() {\n    return hexlify(_classPrivateFieldGet(_data2, this));\n  }\n  get dataLength() {\n    return _classPrivateFieldGet(_data2, this).length;\n  }\n  get consumed() {\n    return _classPrivateFieldGet(_offset, this);\n  }\n  get bytes() {\n    return new Uint8Array(_classPrivateFieldGet(_data2, this));\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    const reader = new Reader(_classPrivateFieldGet(_data2, this).slice(_classPrivateFieldGet(_offset, this) + offset), this.allowLoose, _classPrivateFieldGet(_maxInflation, this));\n    _classPrivateFieldSet(_parent, reader, this);\n    return reader;\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = _assertClassBrand(_Reader_brand, this, _peekBytes).call(this, 0, length, !!loose);\n    _assertClassBrand(_Reader_brand, this, _incrementBytesRead).call(this, length);\n    _classPrivateFieldSet(_offset, this, _classPrivateFieldGet(_offset, this) + bytes.length);\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return toBigInt(this.readBytes(WordSize));\n  }\n  readIndex() {\n    return toNumber(this.readBytes(WordSize));\n  }\n}\n//# sourceMappingURL=abstract-coder.js.map\nfunction _incrementBytesRead(count) {\n  if (_classPrivateFieldGet(_parent, this)) {\n    var _classPrivateFieldGet2;\n    return _assertClassBrand(_Reader_brand, _classPrivateFieldGet2 = _classPrivateFieldGet(_parent, this), _incrementBytesRead).call(_classPrivateFieldGet2, count);\n  }\n  _classPrivateFieldSet(_bytesRead, this, _classPrivateFieldGet(_bytesRead, this) + count);\n  // Check for excessive inflation (see: #4537)\n  assert(_classPrivateFieldGet(_maxInflation, this) < 1 || _classPrivateFieldGet(_bytesRead, this) <= _classPrivateFieldGet(_maxInflation, this) * this.dataLength, \"compressed ABI data exceeds inflation ratio of \".concat(_classPrivateFieldGet(_maxInflation, this), \" ( see: https://github.com/ethers-io/ethers.js/issues/4537 )\"), \"BUFFER_OVERRUN\", {\n    buffer: getBytesCopy(_classPrivateFieldGet(_data2, this)),\n    offset: _classPrivateFieldGet(_offset, this),\n    length: count,\n    info: {\n      bytesRead: _classPrivateFieldGet(_bytesRead, this),\n      dataLength: this.dataLength\n    }\n  });\n}\nfunction _peekBytes(offset, length, loose) {\n  let alignedLength = Math.ceil(length / WordSize) * WordSize;\n  if (_classPrivateFieldGet(_offset, this) + alignedLength > _classPrivateFieldGet(_data2, this).length) {\n    if (this.allowLoose && loose && _classPrivateFieldGet(_offset, this) + length <= _classPrivateFieldGet(_data2, this).length) {\n      alignedLength = length;\n    } else {\n      assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: getBytesCopy(_classPrivateFieldGet(_data2, this)),\n        length: _classPrivateFieldGet(_data2, this).length,\n        offset: _classPrivateFieldGet(_offset, this) + alignedLength\n      });\n    }\n  }\n  return _classPrivateFieldGet(_data2, this).slice(_classPrivateFieldGet(_offset, this), _classPrivateFieldGet(_offset, this) + alignedLength);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}