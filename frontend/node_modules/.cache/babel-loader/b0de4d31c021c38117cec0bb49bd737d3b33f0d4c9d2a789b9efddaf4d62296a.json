{"ast":null,"code":"/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value, _width) {\n  const value = getUint(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  assert(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n    operation: \"fromTwos\",\n    fault: \"overflow\",\n    value: _value\n  });\n  // Top bit set; treat as a negative value\n  if (value >> width - BN_1) {\n    const mask = (BN_1 << width) - BN_1;\n    return -((~value & mask) + BN_1);\n  }\n  return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value, _width) {\n  let value = getBigInt(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  const limit = BN_1 << width - BN_1;\n  if (value < BN_0) {\n    value = -value;\n    assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n    const mask = (BN_1 << width) - BN_1;\n    return (~value & mask) + BN_1;\n  } else {\n    assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n  }\n  return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value, _bits) {\n  const value = getUint(_value, \"value\");\n  const bits = BigInt(getNumber(_bits, \"bits\"));\n  return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      return value;\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return BigInt(value);\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        if (value[0] === \"-\" && value[1] !== \"-\") {\n          return -BigInt(value.substring(1));\n        }\n        return BigInt(value);\n      } catch (e) {\n        assertArgument(false, \"invalid BigNumberish string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value, name) {\n  const result = getBigInt(value, name);\n  assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n    fault: \"overflow\",\n    operation: \"getUint\",\n    value\n  });\n  return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value) {\n  if (value instanceof Uint8Array) {\n    let result = \"0x0\";\n    for (const v of value) {\n      result += Nibbles[v >> 4];\n      result += Nibbles[v & 0x0f];\n    }\n    return BigInt(result);\n  }\n  return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return Number(value);\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return value;\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        return getNumber(BigInt(value), name);\n      } catch (e) {\n        assertArgument(false, \"invalid numeric string: \".concat(e.message), name || \"value\", value);\n      }\n  }\n  assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value) {\n  return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value, _width) {\n  const value = getUint(_value, \"value\");\n  let result = value.toString(16);\n  if (_width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = \"0\" + result;\n    }\n  } else {\n    const width = getNumber(_width, \"width\");\n    assert(width * 2 >= result.length, \"value exceeds width (\".concat(width, \" bytes)\"), \"NUMERIC_FAULT\", {\n      operation: \"toBeHex\",\n      fault: \"overflow\",\n      value: _value\n    });\n    // Pad the value to the required width\n    while (result.length < width * 2) {\n      result = \"0\" + result;\n    }\n  }\n  return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value) {\n  const value = getUint(_value, \"value\");\n  if (value === BN_0) {\n    return new Uint8Array([]);\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n  const result = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < result.length; i++) {\n    const offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n  return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value) {\n  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n  while (result.startsWith(\"0\")) {\n    result = result.substring(1);\n  }\n  if (result === \"\") {\n    result = \"0\";\n  }\n  return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}