{"ast":null,"code":"import React,{useState,useEffect,useCallback}from'react';import ContactList from'./ContactList';import MessageList from'./MessageList';import MessageSender from'./MessageSender';import ErrorPanel,{useErrors}from'./ErrorPanel';const ChatRoom=_ref=>{var _contractManager$getC;let{contractManager,walletManager,currentUser,onLogout}=_ref;const[selectedContact,setSelectedContact]=useState(null);const[messages,setMessages]=useState([]);const[contacts,setContacts]=useState([]);const[isLoading,setIsLoading]=useState(false);const[messagesLoading,setMessagesLoading]=useState(false);const[balance,setBalance]=useState('0');const[lastMessageCount,setLastMessageCount]=useState(0);const[pollInterval,setPollInterval]=useState(null);const{errors,removeError,addContractError,addTransactionError,addSuccess,addNetworkError}=useErrors();// Load initial data\nuseEffect(()=>{if(contractManager&&currentUser){loadContacts();loadBalance();setupEventListeners();}return()=>{if(contractManager){contractManager.removeMessageListeners();}// Clear polling interval\nif(pollInterval){clearInterval(pollInterval);}};},[contractManager,currentUser]);// Load conversation when contact is selected\nuseEffect(()=>{if(selectedContact&&contractManager){loadConversation(selectedContact);startMessagePolling(selectedContact);}else{setMessages([]);stopMessagePolling();}},[selectedContact,contractManager]);const startMessagePolling=contact=>{// Clear existing interval\nif(pollInterval){clearInterval(pollInterval);}// Start aggressive polling every 1 second for real-time feel\nconst interval=setInterval(async()=>{try{if(contact&&contractManager){const conversation=await contractManager.getConversation(contact);// Only update if message count changed and we're still on the same contact\nif(conversation.length!==lastMessageCount&&selectedContact===contact){const sortedMessages=conversation.sort((a,b)=>a.timestamp-b.timestamp);setMessages(sortedMessages);setLastMessageCount(conversation.length);// Show notification if new messages received\nif(conversation.length>lastMessageCount){const newMessagesCount=conversation.length-lastMessageCount;console.log(\"Polled \".concat(newMessagesCount,\" new messages\"));}}}}catch(error){console.error('Error polling messages:',error);}},1000);// Poll every 1 second for faster updates\nsetPollInterval(interval);};const stopMessagePolling=()=>{if(pollInterval){clearInterval(pollInterval);setPollInterval(null);}};const loadBalance=async()=>{try{if(walletManager){const bal=await walletManager.getBalance();setBalance(bal);}}catch(error){console.error('Error loading balance:',error);}};const loadContacts=async()=>{try{setIsLoading(true);const contactsList=await contractManager.getContacts();setContacts(contactsList);}catch(error){console.error('Error loading contacts:',error);addContractError('Failed to load contacts',error);}finally{setIsLoading(false);}};const loadConversation=async contactAddress=>{try{setMessagesLoading(true);const conversation=await contractManager.getConversation(contactAddress);// Sort messages by timestamp\nconst sortedMessages=conversation.sort((a,b)=>a.timestamp-b.timestamp);setMessages(sortedMessages);setLastMessageCount(sortedMessages.length);}catch(error){console.error('Error loading conversation:',error);addContractError('Failed to load conversation',error);setMessages([]);setLastMessageCount(0);}finally{setMessagesLoading(false);}};const setupEventListeners=()=>{try{// Listen for new messages from blockchain events\ncontractManager.listenForMessages(messageData=>{const{sender,receiver,message,timestamp}=messageData;// Check if this message is relevant to current user\nif(sender===currentUser||receiver===currentUser){console.log('Received new message event:',messageData);const newMessage={sender,receiver,message,timestamp,isRead:false};// Update messages if viewing the relevant conversation\nconst relevantContact=sender===currentUser?receiver:sender;if(selectedContact===relevantContact){setMessages(prev=>{// Avoid duplicate messages - check if message already exists\nconst exists=prev.some(msg=>msg.sender===sender&&msg.receiver===receiver&&Math.abs(msg.timestamp-timestamp)<10000&&// Within 10 seconds\nmsg.message===message);if(!exists){const updated=[...prev,newMessage].sort((a,b)=>a.timestamp-b.timestamp);setLastMessageCount(updated.length);return updated;}return prev;});}// Update contacts list if new contact\nconst contactAddress=sender===currentUser?receiver:sender;if(!contacts.includes(contactAddress)){setContacts(prev=>[...prev,contactAddress]);}// Show notification for received messages only (not sent messages)\nif(sender!==currentUser){addSuccess(\"New message from \".concat(sender.slice(0,6),\"...\").concat(sender.slice(-4)),'New Message');}}});// Listen for public key registrations (for contact updates)\ncontractManager.setupPublicKeyListener(keyData=>{console.log('New public key registered:',keyData);loadContacts();});}catch(error){console.error('Error setting up event listeners:',error);addNetworkError('Failed to set up real-time updates',error);}};const handleSendMessage=async(receiver,messageText)=>{try{if(!messageText.trim()){throw new Error('Message cannot be empty');}if(receiver===currentUser){throw new Error('Cannot send message to yourself');}// Check if receiver has public key\nconst hasKey=await contractManager.hasPublicKey(receiver);if(!hasKey){throw new Error('Receiver has not registered a public key');}// Check wallet balance\nconst currentBalance=parseFloat(await walletManager.getBalance());if(currentBalance<0.001){// Minimum balance check\nthrow new Error('Insufficient balance for transaction fees');}const result=await contractManager.sendMessage(receiver,messageText);// Always add message immediately to UI for better UX\nconst newMessage={sender:currentUser,receiver:receiver,message:messageText,timestamp:Date.now(),isRead:false};setMessages(prev=>{const updated=[...prev,newMessage].sort((a,b)=>a.timestamp-b.timestamp);setLastMessageCount(updated.length);return updated;});// Update contacts if not exists\nif(!contacts.includes(receiver)){setContacts(prev=>[...prev,receiver]);}// Don't show success notification - message appears immediately in UI\nreturn result;}catch(error){console.error('Error sending message:',error);addTransactionError(error.message||'Failed to send message',error);throw error;}};const handleSelectContact=contactAddress=>{setSelectedContact(contactAddress);};const handleAddContact=contactAddress=>{if(!contacts.includes(contactAddress)){setContacts(prev=>[...prev,contactAddress]);setSelectedContact(contactAddress);}};const formatAddress=address=>{return\"\".concat(address.slice(0,6),\"...\").concat(address.slice(-4));};const formatBalance=balance=>{const num=parseFloat(balance);return num.toFixed(4);};return/*#__PURE__*/React.createElement(\"div\",{className:\"chat-room\"},/*#__PURE__*/React.createElement(ErrorPanel,{errors:errors,onDismiss:removeError}),/*#__PURE__*/React.createElement(\"div\",{className:\"chat-container\"},/*#__PURE__*/React.createElement(\"div\",{className:\"chat-sidebar\"},/*#__PURE__*/React.createElement(\"div\",{className:\"sidebar-header\"},/*#__PURE__*/React.createElement(\"div\",{className:\"user-info\"},/*#__PURE__*/React.createElement(\"div\",{className:\"user-avatar\"},formatAddress(currentUser).slice(0,2)),/*#__PURE__*/React.createElement(\"div\",{className:\"user-details\"},/*#__PURE__*/React.createElement(\"div\",{className:\"user-address\"},formatAddress(currentUser)),/*#__PURE__*/React.createElement(\"div\",{className:\"user-balance\"},\"\\uD83D\\uDCB0 \",formatBalance(balance),\" ETH\",parseFloat(balance)<0.01&&/*#__PURE__*/React.createElement(\"a\",{href:\"https://testnet.gblend.xyz/\",target:\"_blank\",rel:\"noopener noreferrer\",className:\"faucet-hint\",title:\"Get free testnet ETH\"},\"\\uD83D\\uDEB0 Faucet\")))),/*#__PURE__*/React.createElement(\"div\",{className:\"sidebar-actions\"},/*#__PURE__*/React.createElement(\"button\",{className:\"btn-icon\",onClick:loadBalance,title:\"Refresh balance\"},\"\\uD83D\\uDD04\"),/*#__PURE__*/React.createElement(\"button\",{className:\"btn-icon logout-btn\",onClick:onLogout,title:\"Disconnect wallet\"},\"\\uD83D\\uDEAA\"))),/*#__PURE__*/React.createElement(ContactList,{contacts:contacts,selectedContact:selectedContact,onSelectContact:handleSelectContact,currentUser:currentUser,contractManager:contractManager,onAddContact:handleAddContact})),/*#__PURE__*/React.createElement(\"div\",{className:\"chat-main\"},selectedContact&&/*#__PURE__*/React.createElement(\"div\",{className:\"chat-header\"},/*#__PURE__*/React.createElement(\"button\",{className:\"btn-back\",onClick:()=>setSelectedContact(null),title:\"Back to welcome screen\"},\"\\u2190 Back\"),/*#__PURE__*/React.createElement(\"div\",{className:\"chat-contact-info\"},/*#__PURE__*/React.createElement(\"div\",{className:\"contact-avatar\"},selectedContact.slice(0,2)),/*#__PURE__*/React.createElement(\"div\",{className:\"contact-address\"},formatAddress(selectedContact)))),/*#__PURE__*/React.createElement(MessageList,{messages:messages,currentUser:currentUser,selectedContact:selectedContact,isLoading:messagesLoading}),/*#__PURE__*/React.createElement(MessageSender,{onSendMessage:handleSendMessage,selectedContact:selectedContact,disabled:isLoading||!contractManager,isLoading:messagesLoading}))),/*#__PURE__*/React.createElement(\"div\",{className:\"network-status\"},/*#__PURE__*/React.createElement(\"div\",{className:\"status-item\"},/*#__PURE__*/React.createElement(\"span\",{className:\"status-indicator active\"}),/*#__PURE__*/React.createElement(\"span\",null,\"Fluent Testnet\")),/*#__PURE__*/React.createElement(\"div\",{className:\"status-item\"},/*#__PURE__*/React.createElement(\"span\",null,\"Contract: \",(_contractManager$getC=contractManager.getContractAddress())===null||_contractManager$getC===void 0?void 0:_contractManager$getC.slice(0,8),\"...\")),/*#__PURE__*/React.createElement(\"div\",{className:\"status-item\"},/*#__PURE__*/React.createElement(\"span\",null,\"\\uD83D\\uDCAC \",messages.length,\" messages\")),/*#__PURE__*/React.createElement(\"div\",{className:\"status-item\"},/*#__PURE__*/React.createElement(\"span\",null,\"\\uD83D\\uDC65 \",contacts.length,\" contacts\"))));};export default ChatRoom;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}