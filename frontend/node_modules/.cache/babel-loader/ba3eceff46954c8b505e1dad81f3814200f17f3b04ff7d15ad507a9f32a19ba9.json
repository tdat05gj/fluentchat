{"ast":null,"code":"import _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { defineProperties } from \"../../utils/properties.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\nimport { pack, unpack } from \"./array.js\";\n/**\n *  @_ignore\n */\nexport class TupleCoder extends Coder {\n  constructor(coders, localName) {\n    let dynamic = false;\n    const types = [];\n    coders.forEach(coder => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n      types.push(coder.type);\n    });\n    const type = \"tuple(\" + types.join(\",\") + \")\";\n    super(\"tuple\", type, localName, dynamic);\n    _defineProperty(this, \"coders\", void 0);\n    defineProperties(this, {\n      coders: Object.freeze(coders.slice())\n    });\n  }\n  defaultValue() {\n    const values = [];\n    this.coders.forEach(coder => {\n      values.push(coder.defaultValue());\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = this.coders.reduce((accum, coder) => {\n      const name = coder.localName;\n      if (name) {\n        if (!accum[name]) {\n          accum[name] = 0;\n        }\n        accum[name]++;\n      }\n      return accum;\n    }, {});\n    // Add named values\n    this.coders.forEach((coder, index) => {\n      let name = coder.localName;\n      if (!name || uniqueNames[name] !== 1) {\n        return;\n      }\n      if (name === \"length\") {\n        name = \"_length\";\n      }\n      if (values[name] != null) {\n        return;\n      }\n      values[name] = values[index];\n    });\n    return Object.freeze(values);\n  }\n  encode(writer, _value) {\n    const value = Typed.dereference(_value, \"tuple\");\n    return pack(writer, this.coders, value);\n  }\n  decode(reader) {\n    return unpack(reader, this.coders);\n  }\n}\n//# sourceMappingURL=tuple.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}