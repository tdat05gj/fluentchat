{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nvar _HDNodeWallet;\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\nimport { computeHmac, randomBytes, ripemd160, SigningKey, sha256 } from \"../crypto/index.js\";\nimport { VoidSigner } from \"../providers/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport { concat, dataSlice, decodeBase58, defineProperties, encodeBase58, getBytes, hexlify, isBytesLike, getNumber, toBeArray, toBigInt, toBeHex, assertPrivate, assert, assertArgument } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\nimport { encryptKeystoreJson, encryptKeystoreJsonSync } from \"./json-keystore.js\";\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n  let result = \"\";\n  while (value) {\n    result = Nibbles[value % 16] + result;\n    value = Math.trunc(value / 16);\n  }\n  while (result.length < length * 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n  const value = getBytes(_value);\n  const check = dataSlice(sha256(sha256(value)), 0, 4);\n  const bytes = concat([value, check]);\n  return encodeBase58(bytes);\n}\nconst _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n  const data = new Uint8Array(37);\n  if (index & HardenedBit) {\n    assert(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"deriveChild\"\n    });\n    // Data = 0x00 || ser_256(k_par)\n    data.set(getBytes(privateKey), 1);\n  } else {\n    // Data = ser_p(point(k_par))\n    data.set(getBytes(publicKey));\n  }\n  // Data += ser_32(i)\n  for (let i = 24; i >= 0; i -= 8) {\n    data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n  }\n  const I = getBytes(computeHmac(\"sha512\", chainCode, data));\n  return {\n    IL: I.slice(0, 32),\n    IR: I.slice(32)\n  };\n}\nfunction derivePath(node, path) {\n  const components = path.split(\"/\");\n  assertArgument(components.length > 0, \"invalid path\", \"path\", path);\n  if (components[0] === \"m\") {\n    assertArgument(node.depth === 0, \"cannot derive root path (i.e. path starting with \\\"m/\\\") for a node at non-zero depth \".concat(node.depth), \"path\", path);\n    components.shift();\n  }\n  let result = node;\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n    if (component.match(/^[0-9]+'$/)) {\n      const index = parseInt(component.substring(0, component.length - 1));\n      assertArgument(index < HardenedBit, \"invalid path index\", \"path[\".concat(i, \"]\"), component);\n      result = result.deriveChild(HardenedBit + index);\n    } else if (component.match(/^[0-9]+$/)) {\n      const index = parseInt(component);\n      assertArgument(index < HardenedBit, \"invalid path index\", \"path[\".concat(i, \"]\"), component);\n      result = result.deriveChild(index);\n    } else {\n      assertArgument(false, \"invalid path component\", \"path[\".concat(i, \"]\"), component);\n    }\n  }\n  return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nvar _HDNodeWallet_brand = /*#__PURE__*/new WeakSet();\nexport class HDNodeWallet extends BaseWallet {\n  /**\n   *  @private\n   */\n  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\n    super(signingKey, provider);\n    _classPrivateMethodInitSpec(this, _HDNodeWallet_brand);\n    /**\n     *  The compressed public key.\n     */\n    _defineProperty(this, \"publicKey\", void 0);\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    _defineProperty(this, \"fingerprint\", void 0);\n    /**\n     *  The parent fingerprint.\n     */\n    _defineProperty(this, \"parentFingerprint\", void 0);\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    _defineProperty(this, \"mnemonic\", void 0);\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    _defineProperty(this, \"chainCode\", void 0);\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provide full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  encode it.\n     */\n    _defineProperty(this, \"path\", void 0);\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    _defineProperty(this, \"depth\", void 0);\n    assertPrivate(guard, _guard, \"HDNodeWallet\");\n    defineProperties(this, {\n      publicKey: signingKey.compressedPublicKey\n    });\n    const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);\n    defineProperties(this, {\n      parentFingerprint,\n      fingerprint,\n      chainCode,\n      path,\n      index,\n      depth\n    });\n    defineProperties(this, {\n      mnemonic\n    });\n  }\n  connect(provider) {\n    return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n  }\n  /**\n   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n   *  %%password%%.\n   *\n   *  If %%progressCallback%% is specified, it will receive periodic\n   *  updates as the encryption process progreses.\n   */\n  async encrypt(password, progressCallback) {\n    return await encryptKeystoreJson(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password, {\n      progressCallback\n    });\n  }\n  /**\n   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n   *  %%password%%.\n   *\n   *  It is preferred to use the [async version](encrypt) instead,\n   *  which allows a [[ProgressCallback]] to keep the user informed.\n   *\n   *  This method will block the event loop (freezing all UI) until\n   *  it is complete, which may be a non-trivial duration.\n   */\n  encryptSync(password) {\n    return encryptKeystoreJsonSync(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password);\n  }\n  /**\n   *  The extended key.\n   *\n   *  This key will begin with the prefix ``xpriv`` and can be used to\n   *  reconstruct this HD Node to derive its children.\n   */\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current sentiment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"extendedKey\"\n    });\n    return encodeBase58Check(concat([\"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, concat([\"0x00\", this.privateKey])]));\n  }\n  /**\n   *  Returns true if this wallet has a path, providing a Type Guard\n   *  that the path is non-null.\n   */\n  hasPath() {\n    return this.path != null;\n  }\n  /**\n   *  Returns a neutered HD Node, which removes the private details\n   *  of an HD Node.\n   *\n   *  A neutered node has no private key, but can be used to derive\n   *  child addresses and other public data about the HD Node.\n   */\n  neuter() {\n    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n  }\n  /**\n   *  Return the child for %%index%%.\n   */\n  deriveChild(_index) {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n    // Base path\n    let path = this.path;\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n      if (index & HardenedBit) {\n        path += \"'\";\n      }\n    }\n    const {\n      IR,\n      IL\n    } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));\n    return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n  }\n  /**\n   *  Return the HDNode for %%path%% from this node.\n   */\n  derivePath(path) {\n    return derivePath(this, path);\n  }\n  /**\n   *  Creates a new HD Node from %%extendedKey%%.\n   *\n   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n   *  or full HD Node ([[HDNodeWallet) respectively.\n   */\n  static fromExtendedKey(extendedKey) {\n    const bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact\n    assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n    const depth = bytes[4];\n    const parentFingerprint = hexlify(bytes.slice(5, 9));\n    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n    const chainCode = hexlify(bytes.slice(13, 45));\n    const key = bytes.slice(45, 78);\n    switch (hexlify(bytes.slice(0, 4))) {\n      // Public Key\n      case \"0x0488b21e\":\n      case \"0x043587cf\":\n        {\n          const publicKey = hexlify(key);\n          return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n        }\n      // Private Key\n      case \"0x0488ade4\":\n      case \"0x04358394 \":\n        if (key[0] !== 0) {\n          break;\n        }\n        return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n    }\n    assertArgument(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n  }\n  /**\n   *  Creates a new random HDNode.\n   */\n  static createRandom(password, path, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n    if (path == null) {\n      path = defaultPath;\n    }\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);\n    return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\n   *  Create an HD Node from %%mnemonic%%.\n   */\n  static fromMnemonic(mnemonic, path) {\n    if (!path) {\n      path = defaultPath;\n    }\n    return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\n   *  Creates an HD Node from a mnemonic %%phrase%%.\n   */\n  static fromPhrase(phrase, password, path, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n    if (path == null) {\n      path = defaultPath;\n    }\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);\n    return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\n   *  Creates an HD Node from a %%seed%%.\n   */\n  static fromSeed(seed) {\n    return _fromSeed.call(HDNodeWallet, seed, null);\n  }\n}\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\n_HDNodeWallet = HDNodeWallet;\nfunction _account() {\n  const account = {\n    address: this.address,\n    privateKey: this.privateKey\n  };\n  const m = this.mnemonic;\n  if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n    account.mnemonic = {\n      path: this.path,\n      locale: \"en\",\n      entropy: m.entropy\n    };\n  }\n  return account;\n}\nfunction _fromSeed(_seed, mnemonic) {\n  assertArgument(isBytesLike(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n  const seed = getBytes(_seed, \"seed\");\n  assertArgument(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n  const I = getBytes(computeHmac(\"sha512\", MasterSecret, seed));\n  const signingKey = new SigningKey(hexlify(I.slice(0, 32)));\n  return new _HDNodeWallet(_guard, signingKey, \"0x00000000\", hexlify(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n}\nexport class HDNodeVoidWallet extends VoidSigner {\n  /**\n   *  @private\n   */\n  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\n    super(address, provider);\n    /**\n     *  The compressed public key.\n     */\n    _defineProperty(this, \"publicKey\", void 0);\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    _defineProperty(this, \"fingerprint\", void 0);\n    /**\n     *  The parent node fingerprint.\n     */\n    _defineProperty(this, \"parentFingerprint\", void 0);\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    _defineProperty(this, \"chainCode\", void 0);\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    _defineProperty(this, \"path\", void 0);\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    _defineProperty(this, \"index\", void 0);\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    _defineProperty(this, \"depth\", void 0);\n    assertPrivate(guard, _guard, \"HDNodeVoidWallet\");\n    defineProperties(this, {\n      publicKey\n    });\n    const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);\n    defineProperties(this, {\n      publicKey,\n      fingerprint,\n      parentFingerprint,\n      chainCode,\n      path,\n      index,\n      depth\n    });\n  }\n  connect(provider) {\n    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n  }\n  /**\n   *  The extended key.\n   *\n   *  This key will begin with the prefix ``xpub`` and can be used to\n   *  reconstruct this neutered key to derive its children addresses.\n   */\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current sentiment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"extendedKey\"\n    });\n    return encodeBase58Check(concat([\"0x0488B21E\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));\n  }\n  /**\n   *  Returns true if this wallet has a path, providing a Type Guard\n   *  that the path is non-null.\n   */\n  hasPath() {\n    return this.path != null;\n  }\n  /**\n   *  Return the child for %%index%%.\n   */\n  deriveChild(_index) {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n    // Base path\n    let path = this.path;\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n      if (index & HardenedBit) {\n        path += \"'\";\n      }\n    }\n    const {\n      IR,\n      IL\n    } = ser_I(index, this.chainCode, this.publicKey, null);\n    const Ki = SigningKey.addPoints(IL, this.publicKey, true);\n    const address = computeAddress(Ki);\n    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);\n  }\n  /**\n   *  Return the signer for %%path%% from this node.\n   */\n  derivePath(path) {\n    return derivePath(this, path);\n  }\n}\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n/**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nexport function getAccountPath(_index) {\n  const index = getNumber(_index, \"index\");\n  assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return \"m/44'/60'/\".concat(index, \"'/0/0\");\n}\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nexport function getIndexedAccountPath(_index) {\n  const index = getNumber(_index, \"index\");\n  assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return \"m/44'/60'/0'/0/\".concat(index);\n}\n//# sourceMappingURL=hdwallet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}