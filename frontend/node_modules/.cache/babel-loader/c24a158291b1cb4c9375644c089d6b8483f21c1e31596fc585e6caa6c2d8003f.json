{"ast":null,"code":"var _Wallet;\nimport { SigningKey } from \"../crypto/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { HDNodeWallet } from \"./hdwallet.js\";\nimport { decryptCrowdsaleJson, isCrowdsaleJson } from \"./json-crowdsale.js\";\nimport { decryptKeystoreJson, decryptKeystoreJsonSync, encryptKeystoreJson, encryptKeystoreJsonSync, isKeystoreJson } from \"./json-keystore.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nexport class Wallet extends BaseWallet {\n  /**\n   *  Create a new wallet for the private %%key%%, optionally connected\n   *  to %%provider%%.\n   */\n  constructor(key, provider) {\n    if (typeof key === \"string\" && !key.startsWith(\"0x\")) {\n      key = \"0x\" + key;\n    }\n    let signingKey = typeof key === \"string\" ? new SigningKey(key) : key;\n    super(signingKey, provider);\n  }\n  connect(provider) {\n    return new Wallet(this.signingKey, provider);\n  }\n  /**\n   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n   *  %%password%%.\n   *\n   *  If %%progressCallback%% is specified, it will receive periodic\n   *  updates as the encryption process progreses.\n   */\n  async encrypt(password, progressCallback) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return await encryptKeystoreJson(account, password, {\n      progressCallback\n    });\n  }\n  /**\n   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n   *  %%password%%.\n   *\n   *  It is preferred to use the [async version](encrypt) instead,\n   *  which allows a [[ProgressCallback]] to keep the user informed.\n   *\n   *  This method will block the event loop (freezing all UI) until\n   *  it is complete, which may be a non-trivial duration.\n   */\n  encryptSync(password) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return encryptKeystoreJsonSync(account, password);\n  }\n  /**\n   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n   *  with %%password%%.\n   *\n   *  If %%progress%% is provided, it is called periodically during\n   *  decryption so that any UI can be updated.\n   */\n  static async fromEncryptedJson(json, password, progress) {\n    let account = null;\n    if (isKeystoreJson(json)) {\n      account = await decryptKeystoreJson(json, password, progress);\n    } else if (isCrowdsaleJson(json)) {\n      if (progress) {\n        progress(0);\n        await stall(0);\n      }\n      account = decryptCrowdsaleJson(json, password);\n      if (progress) {\n        progress(1);\n        await stall(0);\n      }\n    }\n    return _fromAccount.call(Wallet, account);\n  }\n  /**\n   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n   *\n   *  The [[fromEncryptedJson]] method is preferred, as this method\n   *  will lock up and freeze the UI during decryption, which may take\n   *  some time.\n   */\n  static fromEncryptedJsonSync(json, password) {\n    let account = null;\n    if (isKeystoreJson(json)) {\n      account = decryptKeystoreJsonSync(json, password);\n    } else if (isCrowdsaleJson(json)) {\n      account = decryptCrowdsaleJson(json, password);\n    } else {\n      assertArgument(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n    }\n    return _fromAccount.call(Wallet, account);\n  }\n  /**\n   *  Creates a new random [[HDNodeWallet]] using the available\n   *  [cryptographic random source](randomBytes).\n   *\n   *  If there is no crytographic random source, this will throw.\n   */\n  static createRandom(provider) {\n    const wallet = HDNodeWallet.createRandom();\n    if (provider) {\n      return wallet.connect(provider);\n    }\n    return wallet;\n  }\n  /**\n   *  Creates a [[HDNodeWallet]] for %%phrase%%.\n   */\n  static fromPhrase(phrase, provider) {\n    const wallet = HDNodeWallet.fromPhrase(phrase);\n    if (provider) {\n      return wallet.connect(provider);\n    }\n    return wallet;\n  }\n}\n//# sourceMappingURL=wallet.js.map\n_Wallet = Wallet;\nfunction _fromAccount(account) {\n  assertArgument(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n  if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n    const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);\n    const wallet = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n    if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n      return wallet;\n    }\n    console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n  }\n  const wallet = new _Wallet(account.privateKey);\n  assertArgument(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n  return wallet;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}