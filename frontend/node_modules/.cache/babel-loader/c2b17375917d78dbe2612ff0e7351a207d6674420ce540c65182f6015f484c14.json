{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\nimport { createGetUrl } from \"./geturl.js\";\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = createGetUrl();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n  try {\n    const match = url.match(reData);\n    if (!match) {\n      throw new Error(\"invalid data\");\n    }\n    return new FetchResponse(200, \"OK\", {\n      \"content-type\": match[1] || \"text/plain\"\n    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));\n  } catch (error) {\n    return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n  }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl) {\n  async function gatewayIpfs(url, signal) {\n    try {\n      const match = url.match(reIpfs);\n      if (!match) {\n        throw new Error(\"invalid link\");\n      }\n      return new FetchRequest(\"\".concat(baseUrl).concat(match[2]));\n    } catch (error) {\n      return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n    }\n  }\n  return gatewayIpfs;\n}\nconst Gateways = {\n  \"data\": dataGatewayFunc,\n  \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */\nvar _listeners = /*#__PURE__*/new WeakMap();\nvar _cancelled = /*#__PURE__*/new WeakMap();\nexport class FetchCancelSignal {\n  constructor(request) {\n    _classPrivateFieldInitSpec(this, _listeners, void 0);\n    _classPrivateFieldInitSpec(this, _cancelled, void 0);\n    _classPrivateFieldSet(_listeners, this, []);\n    _classPrivateFieldSet(_cancelled, this, false);\n    fetchSignals.set(request, () => {\n      if (_classPrivateFieldGet(_cancelled, this)) {\n        return;\n      }\n      _classPrivateFieldSet(_cancelled, this, true);\n      for (const listener of _classPrivateFieldGet(_listeners, this)) {\n        setTimeout(() => {\n          listener();\n        }, 0);\n      }\n      _classPrivateFieldSet(_listeners, this, []);\n    });\n  }\n  addListener(listener) {\n    assert(!_classPrivateFieldGet(_cancelled, this), \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchCancelSignal.addCancelListener\"\n    });\n    _classPrivateFieldGet(_listeners, this).push(listener);\n  }\n  get cancelled() {\n    return _classPrivateFieldGet(_cancelled, this);\n  }\n  checkSignal() {\n    assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n  }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n  if (signal == null) {\n    throw new Error(\"missing signal; should not happen\");\n  }\n  signal.checkSignal();\n  return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nvar _allowInsecure = /*#__PURE__*/new WeakMap();\nvar _gzip = /*#__PURE__*/new WeakMap();\nvar _headers = /*#__PURE__*/new WeakMap();\nvar _method = /*#__PURE__*/new WeakMap();\nvar _timeout = /*#__PURE__*/new WeakMap();\nvar _url = /*#__PURE__*/new WeakMap();\nvar _body = /*#__PURE__*/new WeakMap();\nvar _bodyType = /*#__PURE__*/new WeakMap();\nvar _creds = /*#__PURE__*/new WeakMap();\nvar _preflight = /*#__PURE__*/new WeakMap();\nvar _process = /*#__PURE__*/new WeakMap();\nvar _retry = /*#__PURE__*/new WeakMap();\nvar _signal = /*#__PURE__*/new WeakMap();\nvar _throttle = /*#__PURE__*/new WeakMap();\nvar _getUrlFunc = /*#__PURE__*/new WeakMap();\nvar _FetchRequest_brand = /*#__PURE__*/new WeakSet();\nexport class FetchRequest {\n  /**\n   *  The fetch URL to request.\n   */\n  get url() {\n    return _classPrivateFieldGet(_url, this);\n  }\n  set url(url) {\n    _classPrivateFieldSet(_url, this, String(url));\n  }\n  /**\n   *  The fetch body, if any, to send as the request body. //(default: null)//\n   *\n   *  When setting a body, the intrinsic ``Content-Type`` is automatically\n   *  set and will be used if **not overridden** by setting a custom\n   *  header.\n   *\n   *  If %%body%% is null, the body is cleared (along with the\n   *  intrinsic ``Content-Type``).\n   *\n   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n   *  ``text/plain``.\n   *\n   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n   *  ``application/octet-stream``.\n   *\n   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n   *  set to ``application/json``.\n   */\n  get body() {\n    if (_classPrivateFieldGet(_body, this) == null) {\n      return null;\n    }\n    return new Uint8Array(_classPrivateFieldGet(_body, this));\n  }\n  set body(body) {\n    if (body == null) {\n      _classPrivateFieldSet(_body, this, undefined);\n      _classPrivateFieldSet(_bodyType, this, undefined);\n    } else if (typeof body === \"string\") {\n      _classPrivateFieldSet(_body, this, toUtf8Bytes(body));\n      _classPrivateFieldSet(_bodyType, this, \"text/plain\");\n    } else if (body instanceof Uint8Array) {\n      _classPrivateFieldSet(_body, this, body);\n      _classPrivateFieldSet(_bodyType, this, \"application/octet-stream\");\n    } else if (typeof body === \"object\") {\n      _classPrivateFieldSet(_body, this, toUtf8Bytes(JSON.stringify(body)));\n      _classPrivateFieldSet(_bodyType, this, \"application/json\");\n    } else {\n      throw new Error(\"invalid body\");\n    }\n  }\n  /**\n   *  Returns true if the request has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldGet(_body, this) != null;\n  }\n  /**\n   *  The HTTP method to use when requesting the URI. If no method\n   *  has been explicitly set, then ``GET`` is used if the body is\n   *  null and ``POST`` otherwise.\n   */\n  get method() {\n    if (_classPrivateFieldGet(_method, this)) {\n      return _classPrivateFieldGet(_method, this);\n    }\n    if (this.hasBody()) {\n      return \"POST\";\n    }\n    return \"GET\";\n  }\n  set method(method) {\n    if (method == null) {\n      method = \"\";\n    }\n    _classPrivateFieldSet(_method, this, String(method).toUpperCase());\n  }\n  /**\n   *  The headers that will be used when requesting the URI. All\n   *  keys are lower-case.\n   *\n   *  This object is a copy, so any changes will **NOT** be reflected\n   *  in the ``FetchRequest``.\n   *\n   *  To set a header entry, use the ``setHeader`` method.\n   */\n  get headers() {\n    const headers = Object.assign({}, _classPrivateFieldGet(_headers, this));\n    if (_classPrivateFieldGet(_creds, this)) {\n      headers[\"authorization\"] = \"Basic \".concat(encodeBase64(toUtf8Bytes(_classPrivateFieldGet(_creds, this))));\n    }\n    ;\n    if (this.allowGzip) {\n      headers[\"accept-encoding\"] = \"gzip\";\n    }\n    if (headers[\"content-type\"] == null && _classPrivateFieldGet(_bodyType, this)) {\n      headers[\"content-type\"] = _classPrivateFieldGet(_bodyType, this);\n    }\n    if (this.body) {\n      headers[\"content-length\"] = String(this.body.length);\n    }\n    return headers;\n  }\n  /**\n   *  Get the header for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Set the header for %%key%% to %%value%%. All values are coerced\n   *  to a string.\n   */\n  setHeader(key, value) {\n    _classPrivateFieldGet(_headers, this)[String(key).toLowerCase()] = String(value);\n  }\n  /**\n   *  Clear all headers, resetting all intrinsic headers.\n   */\n  clearHeaders() {\n    _classPrivateFieldSet(_headers, this, {});\n  }\n  [Symbol.iterator]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   *  The value that will be sent for the ``Authorization`` header.\n   *\n   *  To set the credentials, use the ``setCredentials`` method.\n   */\n  get credentials() {\n    return _classPrivateFieldGet(_creds, this) || null;\n  }\n  /**\n   *  Sets an ``Authorization`` for %%username%% with %%password%%.\n   */\n  setCredentials(username, password) {\n    assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n    _classPrivateFieldSet(_creds, this, \"\".concat(username, \":\").concat(password));\n  }\n  /**\n   *  Enable and request gzip-encoded responses. The response will\n   *  automatically be decompressed. //(default: true)//\n   */\n  get allowGzip() {\n    return _classPrivateFieldGet(_gzip, this);\n  }\n  set allowGzip(value) {\n    _classPrivateFieldSet(_gzip, this, !!value);\n  }\n  /**\n   *  Allow ``Authentication`` credentials to be sent over insecure\n   *  channels. //(default: false)//\n   */\n  get allowInsecureAuthentication() {\n    return !!_classPrivateFieldGet(_allowInsecure, this);\n  }\n  set allowInsecureAuthentication(value) {\n    _classPrivateFieldSet(_allowInsecure, this, !!value);\n  }\n  /**\n   *  The timeout (in milliseconds) to wait for a complete response.\n   *  //(default: 5 minutes)//\n   */\n  get timeout() {\n    return _classPrivateFieldGet(_timeout, this);\n  }\n  set timeout(timeout) {\n    assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n    _classPrivateFieldSet(_timeout, this, timeout);\n  }\n  /**\n   *  This function is called prior to each request, for example\n   *  during a redirection or retry in case of server throttling.\n   *\n   *  This offers an opportunity to populate headers or update\n   *  content before sending a request.\n   */\n  get preflightFunc() {\n    return _classPrivateFieldGet(_preflight, this) || null;\n  }\n  set preflightFunc(preflight) {\n    _classPrivateFieldSet(_preflight, this, preflight);\n  }\n  /**\n   *  This function is called after each response, offering an\n   *  opportunity to provide client-level throttling or updating\n   *  response data.\n   *\n   *  Any error thrown in this causes the ``send()`` to throw.\n   *\n   *  To schedule a retry attempt (assuming the maximum retry limit\n   *  has not been reached), use [[response.throwThrottleError]].\n   */\n  get processFunc() {\n    return _classPrivateFieldGet(_process, this) || null;\n  }\n  set processFunc(process) {\n    _classPrivateFieldSet(_process, this, process);\n  }\n  /**\n   *  This function is called on each retry attempt.\n   */\n  get retryFunc() {\n    return _classPrivateFieldGet(_retry, this) || null;\n  }\n  set retryFunc(retry) {\n    _classPrivateFieldSet(_retry, this, retry);\n  }\n  /**\n   *  This function is called to fetch content from HTTP and\n   *  HTTPS URLs and is platform specific (e.g. nodejs vs\n   *  browsers).\n   *\n   *  This is by default the currently registered global getUrl\n   *  function, which can be changed using [[registerGetUrl]].\n   *  If this has been set, setting is to ``null`` will cause\n   *  this FetchRequest (and any future clones) to revert back to\n   *  using the currently registered global getUrl function.\n   *\n   *  Setting this is generally not necessary, but may be useful\n   *  for developers that wish to intercept requests or to\n   *  configurege a proxy or other agent.\n   */\n  get getUrlFunc() {\n    return _classPrivateFieldGet(_getUrlFunc, this) || defaultGetUrlFunc;\n  }\n  set getUrlFunc(value) {\n    _classPrivateFieldSet(_getUrlFunc, this, value);\n  }\n  /**\n   *  Create a new FetchRequest instance with default values.\n   *\n   *  Once created, each property may be set before issuing a\n   *  ``.send()`` to make the request.\n   */\n  constructor(url) {\n    _classPrivateMethodInitSpec(this, _FetchRequest_brand);\n    _classPrivateFieldInitSpec(this, _allowInsecure, void 0);\n    _classPrivateFieldInitSpec(this, _gzip, void 0);\n    _classPrivateFieldInitSpec(this, _headers, void 0);\n    _classPrivateFieldInitSpec(this, _method, void 0);\n    _classPrivateFieldInitSpec(this, _timeout, void 0);\n    _classPrivateFieldInitSpec(this, _url, void 0);\n    _classPrivateFieldInitSpec(this, _body, void 0);\n    _classPrivateFieldInitSpec(this, _bodyType, void 0);\n    _classPrivateFieldInitSpec(this, _creds, void 0);\n    // Hooks\n    _classPrivateFieldInitSpec(this, _preflight, void 0);\n    _classPrivateFieldInitSpec(this, _process, void 0);\n    _classPrivateFieldInitSpec(this, _retry, void 0);\n    _classPrivateFieldInitSpec(this, _signal, void 0);\n    _classPrivateFieldInitSpec(this, _throttle, void 0);\n    _classPrivateFieldInitSpec(this, _getUrlFunc, void 0);\n    _classPrivateFieldSet(_url, this, String(url));\n    _classPrivateFieldSet(_allowInsecure, this, false);\n    _classPrivateFieldSet(_gzip, this, true);\n    _classPrivateFieldSet(_headers, this, {});\n    _classPrivateFieldSet(_method, this, \"\");\n    _classPrivateFieldSet(_timeout, this, 300000);\n    _classPrivateFieldSet(_throttle, this, {\n      slotInterval: SLOT_INTERVAL,\n      maxAttempts: MAX_ATTEMPTS\n    });\n    _classPrivateFieldSet(_getUrlFunc, this, null);\n  }\n  toString() {\n    return \"<FetchRequest method=\".concat(JSON.stringify(this.method), \" url=\").concat(JSON.stringify(this.url), \" headers=\").concat(JSON.stringify(this.headers), \" body=\").concat(_classPrivateFieldGet(_body, this) ? hexlify(_classPrivateFieldGet(_body, this)) : \"null\", \">\");\n  }\n  /**\n   *  Update the throttle parameters used to determine maximum\n   *  attempts and exponential-backoff properties.\n   */\n  setThrottleParams(params) {\n    if (params.slotInterval != null) {\n      _classPrivateFieldGet(_throttle, this).slotInterval = params.slotInterval;\n    }\n    if (params.maxAttempts != null) {\n      _classPrivateFieldGet(_throttle, this).maxAttempts = params.maxAttempts;\n    }\n  }\n  /**\n   *  Resolves to the response by sending the request.\n   */\n  send() {\n    assert(_classPrivateFieldGet(_signal, this) == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.send\"\n    });\n    _classPrivateFieldSet(_signal, this, new FetchCancelSignal(this));\n    return _assertClassBrand(_FetchRequest_brand, this, _send).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n  }\n  /**\n   *  Cancels the inflight response, causing a ``CANCELLED``\n   *  error to be rejected from the [[send]].\n   */\n  cancel() {\n    assert(_classPrivateFieldGet(_signal, this) != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fetchRequest.cancel\"\n    });\n    const signal = fetchSignals.get(this);\n    if (!signal) {\n      throw new Error(\"missing signal; should not happen\");\n    }\n    signal();\n  }\n  /**\n   *  Returns a new [[FetchRequest]] that represents the redirection\n   *  to %%location%%.\n   */\n  redirect(location) {\n    // Redirection; for now we only support absolute locations\n    const current = this.url.split(\":\")[0].toLowerCase();\n    const target = location.split(\":\")[0].toLowerCase();\n    // Don't allow redirecting:\n    // - non-GET requests\n    // - downgrading the security (e.g. https => http)\n    // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n    assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), \"unsupported redirect\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"redirect(\".concat(this.method, \" \").concat(JSON.stringify(this.url), \" => \").concat(JSON.stringify(location), \")\")\n    });\n    // Create a copy of this request, with a new URL\n    const req = new FetchRequest(location);\n    req.method = \"GET\";\n    req.allowGzip = this.allowGzip;\n    req.timeout = this.timeout;\n    _classPrivateFieldSet(_headers, req, Object.assign({}, _classPrivateFieldGet(_headers, this)));\n    if (_classPrivateFieldGet(_body, this)) {\n      _classPrivateFieldSet(_body, req, new Uint8Array(_classPrivateFieldGet(_body, this)));\n    }\n    _classPrivateFieldSet(_bodyType, req, _classPrivateFieldGet(_bodyType, this));\n    // Do not forward credentials unless on the same domain; only absolute\n    //req.allowInsecure = false;\n    // paths are currently supported; may want a way to specify to forward?\n    //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n    return req;\n  }\n  /**\n   *  Create a new copy of this request.\n   */\n  clone() {\n    const clone = new FetchRequest(this.url);\n    // Preserve \"default method\" (i.e. null)\n    _classPrivateFieldSet(_method, clone, _classPrivateFieldGet(_method, this));\n    // Preserve \"default body\" with type, copying the Uint8Array is present\n    if (_classPrivateFieldGet(_body, this)) {\n      _classPrivateFieldSet(_body, clone, _classPrivateFieldGet(_body, this));\n    }\n    _classPrivateFieldSet(_bodyType, clone, _classPrivateFieldGet(_bodyType, this));\n    // Preserve \"default headers\"\n    _classPrivateFieldSet(_headers, clone, Object.assign({}, _classPrivateFieldGet(_headers, this)));\n    // Credentials is readonly, so we copy internally\n    _classPrivateFieldSet(_creds, clone, _classPrivateFieldGet(_creds, this));\n    if (this.allowGzip) {\n      clone.allowGzip = true;\n    }\n    clone.timeout = this.timeout;\n    if (this.allowInsecureAuthentication) {\n      clone.allowInsecureAuthentication = true;\n    }\n    _classPrivateFieldSet(_preflight, clone, _classPrivateFieldGet(_preflight, this));\n    _classPrivateFieldSet(_process, clone, _classPrivateFieldGet(_process, this));\n    _classPrivateFieldSet(_retry, clone, _classPrivateFieldGet(_retry, this));\n    _classPrivateFieldSet(_throttle, clone, Object.assign({}, _classPrivateFieldGet(_throttle, this)));\n    _classPrivateFieldSet(_getUrlFunc, clone, _classPrivateFieldGet(_getUrlFunc, this));\n    return clone;\n  }\n  /**\n   *  Locks all static configuration for gateways and FetchGetUrlFunc\n   *  registration.\n   */\n  static lockConfig() {\n    locked = true;\n  }\n  /**\n   *  Get the current Gateway function for %%scheme%%.\n   */\n  static getGateway(scheme) {\n    return Gateways[scheme.toLowerCase()] || null;\n  }\n  /**\n   *  Use the %%func%% when fetching URIs using %%scheme%%.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGateway(scheme, func) {\n    scheme = scheme.toLowerCase();\n    if (scheme === \"http\" || scheme === \"https\") {\n      throw new Error(\"cannot intercept \".concat(scheme, \"; use registerGetUrl\"));\n    }\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    Gateways[scheme] = func;\n  }\n  /**\n   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n   *\n   *  This method affects all requests globally.\n   *\n   *  If [[lockConfig]] has been called, no change is made and this\n   *  throws.\n   */\n  static registerGetUrl(getUrl) {\n    if (locked) {\n      throw new Error(\"gateways locked\");\n    }\n    defaultGetUrlFunc = getUrl;\n  }\n  /**\n   *  Creates a getUrl function that fetches content from HTTP and\n   *  HTTPS URLs.\n   *\n   *  The available %%options%% are dependent on the platform\n   *  implementation of the default getUrl function.\n   *\n   *  This is not generally something that is needed, but is useful\n   *  when trying to customize simple behaviour when fetching HTTP\n   *  content.\n   */\n  static createGetUrlFunc(options) {\n    return createGetUrl(options);\n  }\n  /**\n   *  Creates a function that can \"fetch\" data URIs.\n   *\n   *  Note that this is automatically done internally to support\n   *  data URIs, so it is not necessary to register it.\n   *\n   *  This is not generally something that is needed, but may\n   *  be useful in a wrapper to perfom custom data URI functionality.\n   */\n  static createDataGateway() {\n    return dataGatewayFunc;\n  }\n  /**\n   *  Creates a function that will fetch IPFS (unvalidated) from\n   *  a custom gateway baseUrl.\n   *\n   *  The default IPFS gateway used internally is\n   *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n   */\n  static createIpfsGatewayFunc(baseUrl) {\n    return getIpfsGatewayFunc(baseUrl);\n  }\n}\nasync function _send(attempt, expires, delay, _request, _response) {\n  if (attempt >= _classPrivateFieldGet(_throttle, this).maxAttempts) {\n    return _response.makeServerError(\"exceeded maximum retry limit\");\n  }\n  assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n    operation: \"request.send\",\n    reason: \"timeout\",\n    request: _request\n  });\n  if (delay > 0) {\n    await wait(delay);\n  }\n  let req = this.clone();\n  const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n  // Process any Gateways\n  if (scheme in Gateways) {\n    const result = await Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet(_signal, _request)));\n    if (result instanceof FetchResponse) {\n      let response = result;\n      if (this.processFunc) {\n        checkSignal(_classPrivateFieldGet(_signal, _request));\n        try {\n          response = await this.processFunc(req, response);\n        } catch (error) {\n          // Something went wrong during processing; throw a 5xx server error\n          if (error.throttle == null || typeof error.stall !== \"number\") {\n            response.makeServerError(\"error in post-processing function\", error).assertOk();\n          }\n          // Ignore throttling\n        }\n      }\n      return response;\n    }\n    req = result;\n  }\n  // We have a preflight function; update the request\n  if (this.preflightFunc) {\n    req = await this.preflightFunc(req);\n  }\n  const resp = await this.getUrlFunc(req, checkSignal(_classPrivateFieldGet(_signal, _request)));\n  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n  if (response.statusCode === 301 || response.statusCode === 302) {\n    // Redirect\n    try {\n      var _req$redirect;\n      const location = response.headers.location || \"\";\n      return _assertClassBrand(_FetchRequest_brand, _req$redirect = req.redirect(location), _send).call(_req$redirect, attempt + 1, expires, 0, _request, response);\n    } catch (error) {}\n    // Things won't get any better on another attempt; abort\n    return response;\n  } else if (response.statusCode === 429) {\n    // Throttle\n    if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n      var _req$clone;\n      const retryAfter = response.headers[\"retry-after\"];\n      let delay = _classPrivateFieldGet(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n        delay = parseInt(retryAfter);\n      }\n      return _assertClassBrand(_FetchRequest_brand, _req$clone = req.clone(), _send).call(_req$clone, attempt + 1, expires, delay, _request, response);\n    }\n  }\n  if (this.processFunc) {\n    checkSignal(_classPrivateFieldGet(_signal, _request));\n    try {\n      response = await this.processFunc(req, response);\n    } catch (error) {\n      var _req$clone2;\n      // Something went wrong during processing; throw a 5xx server error\n      if (error.throttle == null || typeof error.stall !== \"number\") {\n        response.makeServerError(\"error in post-processing function\", error).assertOk();\n      }\n      // Throttle\n      let delay = _classPrivateFieldGet(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n      ;\n      if (error.stall >= 0) {\n        delay = error.stall;\n      }\n      return _assertClassBrand(_FetchRequest_brand, _req$clone2 = req.clone(), _send).call(_req$clone2, attempt + 1, expires, delay, _request, response);\n    }\n  }\n  return response;\n}\n;\n/**\n *  The response for a FetchRequest.\n */\nvar _statusCode = /*#__PURE__*/new WeakMap();\nvar _statusMessage = /*#__PURE__*/new WeakMap();\nvar _headers2 = /*#__PURE__*/new WeakMap();\nvar _body2 = /*#__PURE__*/new WeakMap();\nvar _request2 = /*#__PURE__*/new WeakMap();\nvar _error = /*#__PURE__*/new WeakMap();\nexport class FetchResponse {\n  toString() {\n    return \"<FetchResponse status=\".concat(this.statusCode, \" body=\").concat(_classPrivateFieldGet(_body2, this) ? hexlify(_classPrivateFieldGet(_body2, this)) : \"null\", \">\");\n  }\n  /**\n   *  The response status code.\n   */\n  get statusCode() {\n    return _classPrivateFieldGet(_statusCode, this);\n  }\n  /**\n   *  The response status message.\n   */\n  get statusMessage() {\n    return _classPrivateFieldGet(_statusMessage, this);\n  }\n  /**\n   *  The response headers. All keys are lower-case.\n   */\n  get headers() {\n    return Object.assign({}, _classPrivateFieldGet(_headers2, this));\n  }\n  /**\n   *  The response body, or ``null`` if there was no body.\n   */\n  get body() {\n    return _classPrivateFieldGet(_body2, this) == null ? null : new Uint8Array(_classPrivateFieldGet(_body2, this));\n  }\n  /**\n   *  The response body as a UTF-8 encoded string, or the empty\n   *  string (i.e. ``\"\"``) if there was no body.\n   *\n   *  An error is thrown if the body is invalid UTF-8 data.\n   */\n  get bodyText() {\n    try {\n      return _classPrivateFieldGet(_body2, this) == null ? \"\" : toUtf8String(_classPrivateFieldGet(_body2, this));\n    } catch (error) {\n      assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyText\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  /**\n   *  The response body, decoded as JSON.\n   *\n   *  An error is thrown if the body is invalid JSON-encoded data\n   *  or if there was no body.\n   */\n  get bodyJson() {\n    try {\n      return JSON.parse(this.bodyText);\n    } catch (error) {\n      assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"bodyJson\",\n        info: {\n          response: this\n        }\n      });\n    }\n  }\n  [Symbol.iterator]() {\n    const headers = this.headers;\n    const keys = Object.keys(headers);\n    let index = 0;\n    return {\n      next: () => {\n        if (index < keys.length) {\n          const key = keys[index++];\n          return {\n            value: [key, headers[key]],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  constructor(statusCode, statusMessage, headers, body, request) {\n    _classPrivateFieldInitSpec(this, _statusCode, void 0);\n    _classPrivateFieldInitSpec(this, _statusMessage, void 0);\n    _classPrivateFieldInitSpec(this, _headers2, void 0);\n    _classPrivateFieldInitSpec(this, _body2, void 0);\n    _classPrivateFieldInitSpec(this, _request2, void 0);\n    _classPrivateFieldInitSpec(this, _error, void 0);\n    _classPrivateFieldSet(_statusCode, this, statusCode);\n    _classPrivateFieldSet(_statusMessage, this, statusMessage);\n    _classPrivateFieldSet(_headers2, this, Object.keys(headers).reduce((accum, k) => {\n      accum[k.toLowerCase()] = String(headers[k]);\n      return accum;\n    }, {}));\n    _classPrivateFieldSet(_body2, this, body == null ? null : new Uint8Array(body));\n    _classPrivateFieldSet(_request2, this, request || null);\n    _classPrivateFieldSet(_error, this, {\n      message: \"\"\n    });\n  }\n  /**\n   *  Return a Response with matching headers and body, but with\n   *  an error status code (i.e. 599) and %%message%% with an\n   *  optional %%error%%.\n   */\n  makeServerError(message, error) {\n    let statusMessage;\n    if (!message) {\n      message = \"\".concat(this.statusCode, \" \").concat(this.statusMessage);\n      statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(message, \")\");\n    } else {\n      statusMessage = \"CLIENT ESCALATED SERVER ERROR (\".concat(this.statusCode, \" \").concat(this.statusMessage, \"; \").concat(message, \")\");\n    }\n    const response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet(_request2, this) || undefined);\n    _classPrivateFieldSet(_error, response, {\n      message,\n      error\n    });\n    return response;\n  }\n  /**\n   *  If called within a [request.processFunc](FetchRequest-processFunc)\n   *  call, causes the request to retry as if throttled for %%stall%%\n   *  milliseconds.\n   */\n  throwThrottleError(message, stall) {\n    if (stall == null) {\n      stall = -1;\n    } else {\n      assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n    }\n    const error = new Error(message || \"throttling requests\");\n    defineProperties(error, {\n      stall,\n      throttle: true\n    });\n    throw error;\n  }\n  /**\n   *  Get the header value for %%key%%, ignoring case.\n   */\n  getHeader(key) {\n    return this.headers[key.toLowerCase()];\n  }\n  /**\n   *  Returns true if the response has a body.\n   */\n  hasBody() {\n    return _classPrivateFieldGet(_body2, this) != null;\n  }\n  /**\n   *  The request made for this response.\n   */\n  get request() {\n    return _classPrivateFieldGet(_request2, this);\n  }\n  /**\n   *  Returns true if this response was a success statusCode.\n   */\n  ok() {\n    return _classPrivateFieldGet(_error, this).message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n  }\n  /**\n   *  Throws a ``SERVER_ERROR`` if this response is not ok.\n   */\n  assertOk() {\n    if (this.ok()) {\n      return;\n    }\n    let {\n      message,\n      error\n    } = _classPrivateFieldGet(_error, this);\n    if (message === \"\") {\n      message = \"server response \".concat(this.statusCode, \" \").concat(this.statusMessage);\n    }\n    let requestUrl = null;\n    if (this.request) {\n      requestUrl = this.request.url;\n    }\n    let responseBody = null;\n    try {\n      if (_classPrivateFieldGet(_body2, this)) {\n        responseBody = toUtf8String(_classPrivateFieldGet(_body2, this));\n      }\n    } catch (e) {}\n    assert(false, message, \"SERVER_ERROR\", {\n      request: this.request || \"unknown request\",\n      response: this,\n      error,\n      info: {\n        requestUrl,\n        responseBody,\n        responseStatus: \"\".concat(this.statusCode, \" \").concat(this.statusMessage)\n      }\n    });\n  }\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction unpercent(value) {\n  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n    return String.fromCharCode(parseInt(code, 16));\n  }));\n}\nfunction wait(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay));\n}\n//# sourceMappingURL=fetch.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}