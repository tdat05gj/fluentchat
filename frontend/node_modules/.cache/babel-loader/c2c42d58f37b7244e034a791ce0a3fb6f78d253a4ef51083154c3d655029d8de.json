{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filterIdPromise = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _hault = /*#__PURE__*/new WeakMap();\nvar _FilterIdSubscriber_brand = /*#__PURE__*/new WeakSet();\nexport class FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _FilterIdSubscriber_brand);\n    _classPrivateFieldInitSpec(this, _provider, void 0);\n    _classPrivateFieldInitSpec(this, _filterIdPromise, void 0);\n    _classPrivateFieldInitSpec(this, _poller, void 0);\n    _classPrivateFieldInitSpec(this, _running, void 0);\n    _classPrivateFieldInitSpec(this, _network, void 0);\n    _classPrivateFieldInitSpec(this, _hault, void 0);\n    _classPrivateFieldSet(_provider, this, provider);\n    _classPrivateFieldSet(_filterIdPromise, this, null);\n    _classPrivateFieldSet(_poller, this, _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).bind(this));\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_network, this, null);\n    _classPrivateFieldSet(_hault, this, false);\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, true);\n    _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).call(this, -2);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(_running, this)) {\n      return;\n    }\n    _classPrivateFieldSet(_running, this, false);\n    _classPrivateFieldSet(_hault, this, true);\n    _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);\n    _classPrivateFieldGet(_provider, this).off(\"block\", _classPrivateFieldGet(_poller, this));\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);\n    }\n    _classPrivateFieldGet(_provider, this).off(\"block\", _classPrivateFieldGet(_poller, this));\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nasync function _poll(blockNumber) {\n  try {\n    // Subscribe if necessary\n    if (_classPrivateFieldGet(_filterIdPromise, this) == null) {\n      _classPrivateFieldSet(_filterIdPromise, this, this._subscribe(_classPrivateFieldGet(_provider, this)));\n    }\n    // Get the Filter ID\n    let filterId = null;\n    try {\n      filterId = await _classPrivateFieldGet(_filterIdPromise, this);\n    } catch (error) {\n      if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n        throw error;\n      }\n    }\n    // The backend does not support Filter ID; downgrade to\n    // polling\n    if (filterId == null) {\n      _classPrivateFieldSet(_filterIdPromise, this, null);\n      _classPrivateFieldGet(_provider, this)._recoverSubscriber(this, this._recover(_classPrivateFieldGet(_provider, this)));\n      return;\n    }\n    const network = await _classPrivateFieldGet(_provider, this).getNetwork();\n    if (!_classPrivateFieldGet(_network, this)) {\n      _classPrivateFieldSet(_network, this, network);\n    }\n    if (_classPrivateFieldGet(_network, this).chainId !== network.chainId) {\n      throw new Error(\"chaid changed\");\n    }\n    if (_classPrivateFieldGet(_hault, this)) {\n      return;\n    }\n    const result = await _classPrivateFieldGet(_provider, this).send(\"eth_getFilterChanges\", [filterId]);\n    await this._emitResults(_classPrivateFieldGet(_provider, this), result);\n  } catch (error) {\n    console.log(\"@TODO\", error);\n  }\n  _classPrivateFieldGet(_provider, this).once(\"block\", _classPrivateFieldGet(_poller, this));\n}\nfunction _teardown() {\n  const filterIdPromise = _classPrivateFieldGet(_filterIdPromise, this);\n  if (filterIdPromise) {\n    _classPrivateFieldSet(_filterIdPromise, this, null);\n    filterIdPromise.then(filterId => {\n      if (_classPrivateFieldGet(_provider, this).destroyed) {\n        return;\n      }\n      _classPrivateFieldGet(_provider, this).send(\"eth_uninstallFilter\", [filterId]);\n    });\n  }\n}\nvar _event = /*#__PURE__*/new WeakMap();\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _event, void 0);\n    _classPrivateFieldSet(_event, this, copy(filter));\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, _classPrivateFieldGet(_event, this));\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [_classPrivateFieldGet(_event, this)]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(_classPrivateFieldGet(_event, this), provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}\n//# sourceMappingURL=subscriber-filterid.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}