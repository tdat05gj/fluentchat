{"ast":null,"code":"// Cipher Block Chaining\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CBC_iv, _CBC_lastBlock;\nimport { ModeOfOperation } from \"./mode.js\";\nexport class CBC extends ModeOfOperation {\n  constructor(key, iv) {\n    super(\"ECC\", key, CBC);\n    _CBC_iv.set(this, void 0);\n    _CBC_lastBlock.set(this, void 0);\n    if (iv) {\n      if (iv.length % 16) {\n        throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n      }\n      __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\n    } else {\n      __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\n    }\n    __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\n  }\n  get iv() {\n    return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\"));\n  }\n  encrypt(plaintext) {\n    if (plaintext.length % 16) {\n      throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n    }\n    const ciphertext = new Uint8Array(plaintext.length);\n    for (let i = 0; i < plaintext.length; i += 16) {\n      for (let j = 0; j < 16; j++) {\n        __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\n      }\n      __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\n      ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\n    }\n    return ciphertext;\n  }\n  decrypt(ciphertext) {\n    if (ciphertext.length % 16) {\n      throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n    }\n    const plaintext = new Uint8Array(ciphertext.length);\n    for (let i = 0; i < ciphertext.length; i += 16) {\n      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\n      for (let j = 0; j < 16; j++) {\n        plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\n        __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\n      }\n    }\n    return plaintext;\n  }\n}\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();\n//# sourceMappingURL=mode-cbc.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}