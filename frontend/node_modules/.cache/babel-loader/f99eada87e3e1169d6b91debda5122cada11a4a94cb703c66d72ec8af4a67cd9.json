{"ast":null,"code":"/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument } from \"./errors.js\";\nimport { toBigInt } from \"./maths.js\";\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n  if (Lookup == null) {\n    Lookup = {};\n    for (let i = 0; i < Alphabet.length; i++) {\n      Lookup[Alphabet[i]] = BigInt(i);\n    }\n  }\n  const result = Lookup[letter];\n  assertArgument(result != null, \"invalid base58 value\", \"letter\", letter);\n  return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nexport function encodeBase58(_value) {\n  const bytes = getBytes(_value);\n  let value = toBigInt(bytes);\n  let result = \"\";\n  while (value) {\n    result = Alphabet[Number(value % BN_58)] + result;\n    value /= BN_58;\n  }\n  // Account for leading padding zeros\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i]) {\n      break;\n    }\n    result = Alphabet[0] + result;\n  }\n  return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nexport function decodeBase58(value) {\n  let result = BN_0;\n  for (let i = 0; i < value.length; i++) {\n    result *= BN_58;\n    result += getAlpha(value[i]);\n  }\n  return result;\n}\n//# sourceMappingURL=base58.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}