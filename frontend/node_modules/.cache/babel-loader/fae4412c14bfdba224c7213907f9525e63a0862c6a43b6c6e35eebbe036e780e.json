{"ast":null,"code":"/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n  const types = type.split(\"|\").map(t => t.trim());\n  for (let i = 0; i < types.length; i++) {\n    switch (type) {\n      case \"any\":\n        return;\n      case \"bigint\":\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        if (typeof value === type) {\n          return;\n        }\n    }\n  }\n  const error = new Error(\"invalid value for type \".concat(type));\n  error.code = \"INVALID_ARGUMENT\";\n  error.argument = \"value.\".concat(name);\n  error.value = value;\n  throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n  const keys = Object.keys(value);\n  const results = await Promise.all(keys.map(k => Promise.resolve(value[k])));\n  return results.reduce((accum, v, index) => {\n    accum[keys[index]] = v;\n    return accum;\n  }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n  for (let key in values) {\n    let value = values[key];\n    const type = types ? types[key] : null;\n    if (type) {\n      checkType(value, type, key);\n    }\n    Object.defineProperty(target, key, {\n      enumerable: true,\n      value,\n      writable: false\n    });\n  }\n}\n//# sourceMappingURL=properties.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}