{"ast":null,"code":"import _classPrivateMethodInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _objectSpread from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"C:/Users/Admin/Desktop/fluent_GJ/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify, authorizationify } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes, isError, makeError, assert, assertArgument, FetchRequest, resolveProperties } from \"../utils/index.js\";\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n  if (value == null || Primitive.indexOf(typeof value) >= 0) {\n    return value;\n  }\n  // Keep any Addressable\n  if (typeof value.getAddress === \"function\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(deepCopy);\n  }\n  if (typeof value === \"object\") {\n    return Object.keys(value).reduce((accum, key) => {\n      accum[key] = value[key];\n      return accum;\n    }, {});\n  }\n  throw new Error(\"should not happen: \".concat(value, \" (\").concat(typeof value, \")\"));\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n  return value;\n}\nfunction isPollable(value) {\n  return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n  polling: false,\n  staticNetwork: null,\n  batchStallTime: 10,\n  batchMaxSize: 1 << 20,\n  batchMaxCount: 100,\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nexport class JsonRpcSigner extends AbstractSigner {\n  constructor(provider, address) {\n    super(provider);\n    _defineProperty(this, \"address\", void 0);\n    address = getAddress(address);\n    defineProperties(this, {\n      address\n    });\n  }\n  connect(provider) {\n    assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"signer.connect\"\n    });\n  }\n  async getAddress() {\n    return this.address;\n  }\n  // JSON-RPC will automatially fill in nonce, etc. so we just check from\n  async populateTransaction(tx) {\n    return await this.populateCall(tx);\n  }\n  // Returns just the hash of the transaction after sent, which is what\n  // the bare JSON-RPC API does;\n  async sendUncheckedTransaction(_tx) {\n    const tx = deepCopy(_tx);\n    const promises = [];\n    // Make sure the from matches the sender\n    if (tx.from) {\n      const _from = tx.from;\n      promises.push((async () => {\n        const from = await resolveAddress(_from, this.provider);\n        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n        tx.from = from;\n      })());\n    } else {\n      tx.from = this.address;\n    }\n    // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n    // wishes to use this, it is easy to specify explicitly, otherwise\n    // we look it up for them.\n    if (tx.gasLimit == null) {\n      promises.push((async () => {\n        tx.gasLimit = await this.provider.estimateGas(_objectSpread(_objectSpread({}, tx), {}, {\n          from: this.address\n        }));\n      })());\n    }\n    // The address may be an ENS name or Addressable\n    if (tx.to != null) {\n      const _to = tx.to;\n      promises.push((async () => {\n        tx.to = await resolveAddress(_to, this.provider);\n      })());\n    }\n    // Wait until all of our properties are filled in\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n  }\n  async sendTransaction(tx) {\n    // This cannot be mined any earlier than any recent block\n    const blockNumber = await this.provider.getBlockNumber();\n    // Send the transaction\n    const hash = await this.sendUncheckedTransaction(tx);\n    // Unfortunately, JSON-RPC only provides and opaque transaction hash\n    // for a response, and we need the actual transaction, so we poll\n    // for it; it should show up very quickly\n    return await new Promise((resolve, reject) => {\n      const timeouts = [1000, 100];\n      let invalids = 0;\n      const checkTx = async () => {\n        try {\n          // Try getting the transaction\n          const tx = await this.provider.getTransaction(hash);\n          if (tx != null) {\n            resolve(tx.replaceableTransaction(blockNumber));\n            return;\n          }\n        } catch (error) {\n          // If we were cancelled: stop polling.\n          // If the data is bad: the node returns bad transactions\n          // If the network changed: calling again will also fail\n          // If unsupported: likely destroyed\n          if (isError(error, \"CANCELLED\") || isError(error, \"BAD_DATA\") || isError(error, \"NETWORK_ERROR\") || isError(error, \"UNSUPPORTED_OPERATION\")) {\n            if (error.info == null) {\n              error.info = {};\n            }\n            error.info.sendTransactionHash = hash;\n            reject(error);\n            return;\n          }\n          // Stop-gap for misbehaving backends; see #4513\n          if (isError(error, \"INVALID_ARGUMENT\")) {\n            invalids++;\n            if (error.info == null) {\n              error.info = {};\n            }\n            error.info.sendTransactionHash = hash;\n            if (invalids > 10) {\n              reject(error);\n              return;\n            }\n          }\n          // Notify anyone that cares; but we will try again, since\n          // it is likely an intermittent service error\n          this.provider.emit(\"error\", makeError(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", {\n            error\n          }));\n        }\n        // Wait another 4 seconds\n        this.provider._setTimeout(() => {\n          checkTx();\n        }, timeouts.pop() || 4000);\n      };\n      checkTx();\n    });\n  }\n  async signTransaction(_tx) {\n    const tx = deepCopy(_tx);\n    // Make sure the from matches the sender\n    if (tx.from) {\n      const from = await resolveAddress(tx.from, this.provider);\n      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n      tx.from = from;\n    } else {\n      tx.from = this.address;\n    }\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n  }\n  async signMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"personal_sign\", [hexlify(message), this.address.toLowerCase()]);\n  }\n  async signTypedData(domain, types, _value) {\n    const value = deepCopy(_value);\n    // Populate any ENS names (in-place)\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async value => {\n      const address = await resolveAddress(value);\n      assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n      return address;\n    });\n    return await this.provider.send(\"eth_signTypedData_v4\", [this.address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);\n  }\n  async unlock(password) {\n    return this.provider.send(\"personal_unlockAccount\", [this.address.toLowerCase(), password, null]);\n  }\n  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n  async _legacySignMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"eth_sign\", [this.address.toLowerCase(), hexlify(message)]);\n  }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nvar _options = /*#__PURE__*/new WeakMap();\nvar _nextId = /*#__PURE__*/new WeakMap();\nvar _payloads = /*#__PURE__*/new WeakMap();\nvar _drainTimer = /*#__PURE__*/new WeakMap();\nvar _notReady = /*#__PURE__*/new WeakMap();\nvar _network = /*#__PURE__*/new WeakMap();\nvar _pendingDetectNetwork = /*#__PURE__*/new WeakMap();\nvar _JsonRpcApiProvider_brand = /*#__PURE__*/new WeakSet();\nexport class JsonRpcApiProvider extends AbstractProvider {\n  constructor(network, options) {\n    super(network, options);\n    _classPrivateMethodInitSpec(this, _JsonRpcApiProvider_brand);\n    _classPrivateFieldInitSpec(this, _options, void 0);\n    // The next ID to use for the JSON-RPC ID field\n    _classPrivateFieldInitSpec(this, _nextId, void 0);\n    // Payloads are queued and triggered in batches using the drainTimer\n    _classPrivateFieldInitSpec(this, _payloads, void 0);\n    _classPrivateFieldInitSpec(this, _drainTimer, void 0);\n    _classPrivateFieldInitSpec(this, _notReady, void 0);\n    _classPrivateFieldInitSpec(this, _network, void 0);\n    _classPrivateFieldInitSpec(this, _pendingDetectNetwork, void 0);\n    _classPrivateFieldSet(_nextId, this, 1);\n    _classPrivateFieldSet(_options, this, Object.assign({}, defaultOptions, options || {}));\n    _classPrivateFieldSet(_payloads, this, []);\n    _classPrivateFieldSet(_drainTimer, this, null);\n    _classPrivateFieldSet(_network, this, null);\n    _classPrivateFieldSet(_pendingDetectNetwork, this, null);\n    {\n      let resolve = null;\n      const promise = new Promise(_resolve => {\n        resolve = _resolve;\n      });\n      _classPrivateFieldSet(_notReady, this, {\n        promise,\n        resolve\n      });\n    }\n    const staticNetwork = this._getOption(\"staticNetwork\");\n    if (typeof staticNetwork === \"boolean\") {\n      assertArgument(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n      if (staticNetwork && network != null) {\n        _classPrivateFieldSet(_network, this, Network.from(network));\n      }\n    } else if (staticNetwork) {\n      // Make sure any static network is compatbile with the provided netwrok\n      assertArgument(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n      _classPrivateFieldSet(_network, this, staticNetwork);\n    }\n  }\n  /**\n   *  Returns the value associated with the option %%key%%.\n   *\n   *  Sub-classes can use this to inquire about configuration options.\n   */\n  _getOption(key) {\n    return _classPrivateFieldGet(_options, this)[key];\n  }\n  /**\n   *  Gets the [[Network]] this provider has committed to. On each call, the network\n   *  is detected, and if it has changed, the call will reject.\n   */\n  get _network() {\n    assert(_classPrivateFieldGet(_network, this), \"network is not available yet\", \"NETWORK_ERROR\");\n    return _classPrivateFieldGet(_network, this);\n  }\n  /**\n   *  Resolves to the non-normalized value by performing %%req%%.\n   *\n   *  Sub-classes may override this to modify behavior of actions,\n   *  and should generally call ``super._perform`` as a fallback.\n   */\n  async _perform(req) {\n    // Legacy networks do not like the type field being passed along (which\n    // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n    if (req.method === \"call\" || req.method === \"estimateGas\") {\n      let tx = req.transaction;\n      if (tx && tx.type != null && getBigInt(tx.type)) {\n        // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n          const feeData = await this.getFeeData();\n          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n            // Network doesn't know about EIP-1559 (and hence type)\n            req = Object.assign({}, req, {\n              transaction: Object.assign({}, tx, {\n                type: undefined\n              })\n            });\n          }\n        }\n      }\n    }\n    const request = this.getRpcRequest(req);\n    if (request != null) {\n      return await this.send(request.method, request.args);\n    }\n    return super._perform(req);\n  }\n  /**\n   *  Sub-classes may override this; it detects the *actual* network that\n   *  we are **currently** connected to.\n   *\n   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n   *  _send primitive must be used instead.\n   */\n  async _detectNetwork() {\n    const network = this._getOption(\"staticNetwork\");\n    if (network) {\n      if (network === true) {\n        if (_classPrivateFieldGet(_network, this)) {\n          return _classPrivateFieldGet(_network, this);\n        }\n      } else {\n        return network;\n      }\n    }\n    if (_classPrivateFieldGet(_pendingDetectNetwork, this)) {\n      return await _classPrivateFieldGet(_pendingDetectNetwork, this);\n    }\n    // If we are ready, use ``send``, which enabled requests to be batched\n    if (this.ready) {\n      _classPrivateFieldSet(_pendingDetectNetwork, this, (async () => {\n        try {\n          const result = Network.from(getBigInt(await this.send(\"eth_chainId\", [])));\n          _classPrivateFieldSet(_pendingDetectNetwork, this, null);\n          return result;\n        } catch (error) {\n          _classPrivateFieldSet(_pendingDetectNetwork, this, null);\n          throw error;\n        }\n      })());\n      return await _classPrivateFieldGet(_pendingDetectNetwork, this);\n    }\n    // We are not ready yet; use the primitive _send\n    _classPrivateFieldSet(_pendingDetectNetwork, this, (async (_this$nextId, _this$nextId2) => {\n      const payload = {\n        id: (_classPrivateFieldSet(_nextId, this, (_this$nextId = _classPrivateFieldGet(_nextId, this), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),\n        method: \"eth_chainId\",\n        params: [],\n        jsonrpc: \"2.0\"\n      };\n      this.emit(\"debug\", {\n        action: \"sendRpcPayload\",\n        payload\n      });\n      let result;\n      try {\n        result = (await this._send(payload))[0];\n        _classPrivateFieldSet(_pendingDetectNetwork, this, null);\n      } catch (error) {\n        _classPrivateFieldSet(_pendingDetectNetwork, this, null);\n        this.emit(\"debug\", {\n          action: \"receiveRpcError\",\n          error\n        });\n        throw error;\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRpcResult\",\n        result\n      });\n      if (\"result\" in result) {\n        return Network.from(getBigInt(result.result));\n      }\n      throw this.getRpcError(payload, result);\n    })());\n    return await _classPrivateFieldGet(_pendingDetectNetwork, this);\n  }\n  /**\n   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n   *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n   *  ``super._start()`` **MUST** be called.\n   *\n   *  Calling it multiple times is safe and has no effect.\n   */\n  _start() {\n    if (_classPrivateFieldGet(_notReady, this) == null || _classPrivateFieldGet(_notReady, this).resolve == null) {\n      return;\n    }\n    _classPrivateFieldGet(_notReady, this).resolve();\n    _classPrivateFieldSet(_notReady, this, null);\n    (async () => {\n      // Bootstrap the network\n      while (_classPrivateFieldGet(_network, this) == null && !this.destroyed) {\n        try {\n          _classPrivateFieldSet(_network, this, await this._detectNetwork());\n        } catch (error) {\n          if (this.destroyed) {\n            break;\n          }\n          console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n          this.emit(\"error\", makeError(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n            event: \"initial-network-discovery\",\n            info: {\n              error\n            }\n          }));\n          await stall(1000);\n        }\n      }\n      // Start dispatching requests\n      _assertClassBrand(_JsonRpcApiProvider_brand, this, _scheduleDrain).call(this);\n    })();\n  }\n  /**\n   *  Resolves once the [[_start]] has been called. This can be used in\n   *  sub-classes to defer sending data until the connection has been\n   *  established.\n   */\n  async _waitUntilReady() {\n    if (_classPrivateFieldGet(_notReady, this) == null) {\n      return;\n    }\n    return await _classPrivateFieldGet(_notReady, this).promise;\n  }\n  /**\n   *  Return a Subscriber that will manage the %%sub%%.\n   *\n   *  Sub-classes may override this to modify the behavior of\n   *  subscription management.\n   */\n  _getSubscriber(sub) {\n    // Pending Filters aren't availble via polling\n    if (sub.type === \"pending\") {\n      return new FilterIdPendingSubscriber(this);\n    }\n    if (sub.type === \"event\") {\n      if (this._getOption(\"polling\")) {\n        return new PollingEventSubscriber(this, sub.filter);\n      }\n      return new FilterIdEventSubscriber(this, sub.filter);\n    }\n    // Orphaned Logs are handled automatically, by the filter, since\n    // logs with removed are emitted by it\n    if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n      return new UnmanagedSubscriber(\"orphan\");\n    }\n    return super._getSubscriber(sub);\n  }\n  /**\n   *  Returns true only if the [[_start]] has been called.\n   */\n  get ready() {\n    return _classPrivateFieldGet(_notReady, this) == null;\n  }\n  /**\n   *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n   *  which has all values hexlified and any numeric values converted\n   *  to Quantity values.\n   */\n  getRpcTransaction(tx) {\n    const result = {};\n    // JSON-RPC now requires numeric values to be \"quantity\" values\n    [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n      let dstKey = key;\n      if (key === \"gasLimit\") {\n        dstKey = \"gas\";\n      }\n      result[dstKey] = toQuantity(getBigInt(tx[key], \"tx.\".concat(key)));\n    });\n    // Make sure addresses and data are lowercase\n    [\"from\", \"to\", \"data\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n      result[key] = hexlify(tx[key]);\n    });\n    // Normalize the access list object\n    if (tx.accessList) {\n      result[\"accessList\"] = accessListify(tx.accessList);\n    }\n    if (tx.blobVersionedHashes) {\n      // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n      result[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map(h => h.toLowerCase());\n    }\n    if (tx.authorizationList) {\n      result[\"authorizationList\"] = tx.authorizationList.map(_a => {\n        const a = authorizationify(_a);\n        return {\n          address: a.address,\n          nonce: toQuantity(a.nonce),\n          chainId: toQuantity(a.chainId),\n          yParity: toQuantity(a.signature.yParity),\n          r: toQuantity(a.signature.r),\n          s: toQuantity(a.signature.s)\n        };\n      });\n    }\n    // @TODO: blobs should probably also be copied over, optionally\n    // accounting for the kzg property to backfill blobVersionedHashes\n    // using the commitment. Or should that be left as an exercise to\n    // the caller?\n    return result;\n  }\n  /**\n   *  Returns the request method and arguments required to perform\n   *  %%req%%.\n   */\n  getRpcRequest(req) {\n    switch (req.method) {\n      case \"chainId\":\n        return {\n          method: \"eth_chainId\",\n          args: []\n        };\n      case \"getBlockNumber\":\n        return {\n          method: \"eth_blockNumber\",\n          args: []\n        };\n      case \"getGasPrice\":\n        return {\n          method: \"eth_gasPrice\",\n          args: []\n        };\n      case \"getPriorityFee\":\n        return {\n          method: \"eth_maxPriorityFeePerGas\",\n          args: []\n        };\n      case \"getBalance\":\n        return {\n          method: \"eth_getBalance\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getTransactionCount\":\n        return {\n          method: \"eth_getTransactionCount\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getCode\":\n        return {\n          method: \"eth_getCode\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n      case \"getStorage\":\n        return {\n          method: \"eth_getStorageAt\",\n          args: [getLowerCase(req.address), \"0x\" + req.position.toString(16), req.blockTag]\n        };\n      case \"broadcastTransaction\":\n        return {\n          method: \"eth_sendRawTransaction\",\n          args: [req.signedTransaction]\n        };\n      case \"getBlock\":\n        if (\"blockTag\" in req) {\n          return {\n            method: \"eth_getBlockByNumber\",\n            args: [req.blockTag, !!req.includeTransactions]\n          };\n        } else if (\"blockHash\" in req) {\n          return {\n            method: \"eth_getBlockByHash\",\n            args: [req.blockHash, !!req.includeTransactions]\n          };\n        }\n        break;\n      case \"getTransaction\":\n        return {\n          method: \"eth_getTransactionByHash\",\n          args: [req.hash]\n        };\n      case \"getTransactionReceipt\":\n        return {\n          method: \"eth_getTransactionReceipt\",\n          args: [req.hash]\n        };\n      case \"call\":\n        return {\n          method: \"eth_call\",\n          args: [this.getRpcTransaction(req.transaction), req.blockTag]\n        };\n      case \"estimateGas\":\n        {\n          return {\n            method: \"eth_estimateGas\",\n            args: [this.getRpcTransaction(req.transaction)]\n          };\n        }\n      case \"getLogs\":\n        if (req.filter && req.filter.address != null) {\n          if (Array.isArray(req.filter.address)) {\n            req.filter.address = req.filter.address.map(getLowerCase);\n          } else {\n            req.filter.address = getLowerCase(req.filter.address);\n          }\n        }\n        return {\n          method: \"eth_getLogs\",\n          args: [req.filter]\n        };\n    }\n    return null;\n  }\n  /**\n   *  Returns an ethers-style Error for the given JSON-RPC error\n   *  %%payload%%, coalescing the various strings and error shapes\n   *  that different nodes return, coercing them into a machine-readable\n   *  standardized error.\n   */\n  getRpcError(payload, _error) {\n    const {\n      method\n    } = payload;\n    const {\n      error\n    } = _error;\n    if (method === \"eth_estimateGas\" && error.message) {\n      const msg = error.message;\n      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n        return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n          transaction: payload.params[0],\n          info: {\n            payload,\n            error\n          }\n        });\n      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {\n        return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n          transaction: payload.params[0],\n          info: {\n            payload,\n            error\n          }\n        });\n      }\n    }\n    if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n      const result = spelunkData(error);\n      const e = AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n      e.info = {\n        error,\n        payload\n      };\n      return e;\n    }\n    // Only estimateGas and call can return arbitrary contract-defined text, so now we\n    // we can process text safely.\n    const message = JSON.stringify(spelunkMessage(error));\n    if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n      const actionMap = {\n        eth_sign: \"signMessage\",\n        personal_sign: \"signMessage\",\n        eth_signTypedData_v4: \"signTypedData\",\n        eth_signTransaction: \"signTransaction\",\n        eth_sendTransaction: \"sendTransaction\",\n        eth_requestAccounts: \"requestAccess\",\n        wallet_requestAccounts: \"requestAccess\"\n      };\n      return makeError(\"user rejected action\", \"ACTION_REJECTED\", {\n        action: actionMap[method] || \"unknown\",\n        reason: \"rejected\",\n        info: {\n          payload,\n          error\n        }\n      });\n    }\n    if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n      const transaction = payload.params[0];\n      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      if (message.match(/nonce/i) && message.match(/too low/i)) {\n        return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      // \"replacement transaction underpriced\"\n      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n        return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n          transaction,\n          info: {\n            error\n          }\n        });\n      }\n      if (message.match(/only replay-protected/i)) {\n        return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n          operation: method,\n          info: {\n            transaction,\n            info: {\n              error\n            }\n          }\n        });\n      }\n    }\n    let unsupported = !!message.match(/the method .* does not exist/i);\n    if (!unsupported) {\n      if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n        unsupported = true;\n      }\n    }\n    if (unsupported) {\n      return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n        operation: payload.method,\n        info: {\n          error,\n          payload\n        }\n      });\n    }\n    return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n      error,\n      payload\n    });\n  }\n  /**\n   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n   *  over the underlying channel. This can be used to call methods\n   *  on the backend that do not have a high-level API within the Provider\n   *  API.\n   *\n   *  This method queues requests according to the batch constraints\n   *  in the options, assigns the request a unique ID.\n   *\n   *  **Do NOT override** this method in sub-classes; instead\n   *  override [[_send]] or force the options values in the\n   *  call to the constructor to modify this method's behavior.\n   */\n  send(method, params) {\n    var _this$nextId3, _this$nextId4;\n    // @TODO: cache chainId?? purge on switch_networks\n    // We have been destroyed; no operations are supported anymore\n    if (this.destroyed) {\n      return Promise.reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n        operation: method\n      }));\n    }\n    const id = (_classPrivateFieldSet(_nextId, this, (_this$nextId3 = _classPrivateFieldGet(_nextId, this), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);\n    const promise = new Promise((resolve, reject) => {\n      _classPrivateFieldGet(_payloads, this).push({\n        resolve,\n        reject,\n        payload: {\n          method,\n          params,\n          id,\n          jsonrpc: \"2.0\"\n        }\n      });\n    });\n    // If there is not a pending drainTimer, set one\n    _assertClassBrand(_JsonRpcApiProvider_brand, this, _scheduleDrain).call(this);\n    return promise;\n  }\n  /**\n   *  Resolves to the [[Signer]] account for  %%address%% managed by\n   *  the client.\n   *\n   *  If the %%address%% is a number, it is used as an index in the\n   *  the accounts from [[listAccounts]].\n   *\n   *  This can only be used on clients which manage accounts (such as\n   *  Geth with imported account or MetaMask).\n   *\n   *  Throws if the account doesn't exist.\n   */\n  async getSigner(address) {\n    if (address == null) {\n      address = 0;\n    }\n    const accountsPromise = this.send(\"eth_accounts\", []);\n    // Account index\n    if (typeof address === \"number\") {\n      const accounts = await accountsPromise;\n      if (address >= accounts.length) {\n        throw new Error(\"no such account\");\n      }\n      return new JsonRpcSigner(this, accounts[address]);\n    }\n    const {\n      accounts\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      accounts: accountsPromise\n    });\n    // Account address\n    address = getAddress(address);\n    for (const account of accounts) {\n      if (getAddress(account) === address) {\n        return new JsonRpcSigner(this, address);\n      }\n    }\n    throw new Error(\"invalid account\");\n  }\n  async listAccounts() {\n    const accounts = await this.send(\"eth_accounts\", []);\n    return accounts.map(a => new JsonRpcSigner(this, a));\n  }\n  destroy() {\n    // Stop processing requests\n    if (_classPrivateFieldGet(_drainTimer, this)) {\n      clearTimeout(_classPrivateFieldGet(_drainTimer, this));\n      _classPrivateFieldSet(_drainTimer, this, null);\n    }\n    // Cancel all pending requests\n    for (const {\n      payload,\n      reject\n    } of _classPrivateFieldGet(_payloads, this)) {\n      reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n        operation: payload.method\n      }));\n    }\n    _classPrivateFieldSet(_payloads, this, []);\n    // Parent clean-up\n    super.destroy();\n  }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nfunction _scheduleDrain() {\n  if (_classPrivateFieldGet(_drainTimer, this)) {\n    return;\n  }\n  // If we aren't using batching, no harm in sending it immediately\n  const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n  _classPrivateFieldSet(_drainTimer, this, setTimeout(() => {\n    _classPrivateFieldSet(_drainTimer, this, null);\n    const payloads = _classPrivateFieldGet(_payloads, this);\n    _classPrivateFieldSet(_payloads, this, []);\n    while (payloads.length) {\n      // Create payload batches that satisfy our batch constraints\n      const batch = [payloads.shift()];\n      while (payloads.length) {\n        if (batch.length === _classPrivateFieldGet(_options, this).batchMaxCount) {\n          break;\n        }\n        batch.push(payloads.shift());\n        const bytes = JSON.stringify(batch.map(p => p.payload));\n        if (bytes.length > _classPrivateFieldGet(_options, this).batchMaxSize) {\n          payloads.unshift(batch.pop());\n          break;\n        }\n      }\n      // Process the result to each payload\n      (async () => {\n        const payload = batch.length === 1 ? batch[0].payload : batch.map(p => p.payload);\n        this.emit(\"debug\", {\n          action: \"sendRpcPayload\",\n          payload\n        });\n        try {\n          const result = await this._send(payload);\n          this.emit(\"debug\", {\n            action: \"receiveRpcResult\",\n            result\n          });\n          // Process results in batch order\n          for (const {\n            resolve,\n            reject,\n            payload\n          } of batch) {\n            if (this.destroyed) {\n              reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n              }));\n              continue;\n            }\n            // Find the matching result\n            const resp = result.filter(r => r.id === payload.id)[0];\n            // No result; the node failed us in unexpected ways\n            if (resp == null) {\n              const error = makeError(\"missing response for request\", \"BAD_DATA\", {\n                value: result,\n                info: {\n                  payload\n                }\n              });\n              this.emit(\"error\", error);\n              reject(error);\n              continue;\n            }\n            // The response is an error\n            if (\"error\" in resp) {\n              reject(this.getRpcError(payload, resp));\n              continue;\n            }\n            // All good; send the result\n            resolve(resp.result);\n          }\n        } catch (error) {\n          this.emit(\"debug\", {\n            action: \"receiveRpcError\",\n            error\n          });\n          for (const {\n            reject\n          } of batch) {\n            // @TODO: augment the error with the payload\n            reject(error);\n          }\n        }\n      })();\n    }\n  }, stallTime));\n}\nvar _pollingInterval = /*#__PURE__*/new WeakMap();\nexport class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n  constructor(network, options) {\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _pollingInterval, void 0);\n    let pollingInterval = this._getOption(\"pollingInterval\");\n    if (pollingInterval == null) {\n      pollingInterval = defaultOptions.pollingInterval;\n    }\n    _classPrivateFieldSet(_pollingInterval, this, pollingInterval);\n  }\n  _getSubscriber(sub) {\n    const subscriber = super._getSubscriber(sub);\n    if (isPollable(subscriber)) {\n      subscriber.pollingInterval = _classPrivateFieldGet(_pollingInterval, this);\n    }\n    return subscriber;\n  }\n  /**\n   *  The polling interval (default: 4000 ms)\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(_pollingInterval, this);\n  }\n  set pollingInterval(value) {\n    if (!Number.isInteger(value) || value < 0) {\n      throw new Error(\"invalid interval\");\n    }\n    _classPrivateFieldSet(_pollingInterval, this, value);\n    this._forEachSubscriber(sub => {\n      if (isPollable(sub)) {\n        sub.pollingInterval = _classPrivateFieldGet(_pollingInterval, this);\n      }\n    });\n  }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nvar _connect = /*#__PURE__*/new WeakMap();\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n  constructor(url, network, options) {\n    if (url == null) {\n      url = \"http:/\\/localhost:8545\";\n    }\n    super(network, options);\n    _classPrivateFieldInitSpec(this, _connect, void 0);\n    if (typeof url === \"string\") {\n      _classPrivateFieldSet(_connect, this, new FetchRequest(url));\n    } else {\n      _classPrivateFieldSet(_connect, this, url.clone());\n    }\n  }\n  _getConnection() {\n    return _classPrivateFieldGet(_connect, this).clone();\n  }\n  async send(method, params) {\n    // All requests are over HTTP, so we can just start handling requests\n    // We do this here rather than the constructor so that we don't send any\n    // requests to the network (i.e. eth_chainId) until we absolutely have to.\n    await this._start();\n    return await super.send(method, params);\n  }\n  async _send(payload) {\n    // Configure a POST connection for the requested method\n    const request = this._getConnection();\n    request.body = JSON.stringify(payload);\n    request.setHeader(\"content-type\", \"application/json\");\n    const response = await request.send();\n    response.assertOk();\n    let resp = response.bodyJson;\n    if (!Array.isArray(resp)) {\n      resp = [resp];\n    }\n    return resp;\n  }\n}\nfunction spelunkData(value) {\n  if (value == null) {\n    return null;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\" && value.message.match(/revert/i) && isHexString(value.data)) {\n    return {\n      message: value.message,\n      data: value.data\n    };\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      const result = spelunkData(value[key]);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return spelunkData(JSON.parse(value));\n    } catch (error) {}\n  }\n  return null;\n}\nfunction _spelunkMessage(value, result) {\n  if (value == null) {\n    return;\n  }\n  // These *are* the droids we're looking for.\n  if (typeof value.message === \"string\") {\n    result.push(value.message);\n  }\n  // Spelunk further...\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      _spelunkMessage(value[key], result);\n    }\n  }\n  // Might be a JSON string we can further descend...\n  if (typeof value === \"string\") {\n    try {\n      return _spelunkMessage(JSON.parse(value), result);\n    } catch (error) {}\n  }\n}\nfunction spelunkMessage(value) {\n  const result = [];\n  _spelunkMessage(value, result);\n  return result;\n}\n//# sourceMappingURL=provider-jsonrpc.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}